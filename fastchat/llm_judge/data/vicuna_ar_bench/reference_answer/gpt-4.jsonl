{"question_id": 71, "answer_id": "gaRgS6rvoqiNVzfDR8DrdR", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["بالطبع، يمكنك استخدام الكود التالي كنقطة بداية. هذا البرنامج سيقرأ ملف نصي ويعد عدد المرات التي تظهر فيها كلمة معينة.\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    std::string wordToFind;\n    std::cout << \"Enter the word to find: \";\n    std::cin >> wordToFind;\n\n    std::ifstream file(\"file.txt\");\n    if (!file) {\n        std::cout << \"Unable to open file\";\n        return 1; // terminate with error\n    }\n\n    std::string word;\n    int count = 0;\n    while (file >> word) {\n        if (word == wordToFind) {\n            count++;\n        }\n    }\n\n    std::cout << \"The word '\" << wordToFind << \"' appears \" << count << \" times in the file.\" << std::endl;\n\n    file.close();\n\n    return 0;\n}\n```\n\nهذا البرنامج يقرأ الكلمات من الملف واحدة تلو الأخرى، ويقارن كل كلمة بالكلمة التي تريد العثور عليها. إذا كانت الكلمات متطابقة، يزيد العداد بواحد. في النهاية، يطبع البرنامج عدد المرات التي ظهرت فيها الكلمة في الملف.\n\nيرجى ملاحظة أن هذا البرنامج يعتبر الكلمات \"Word\" و \"word\" ككلمتين مختلفتين بسبب حساسية الحالة. إذا كنت تريد تجاهل حالة الأحرف، فيمكنك تحويل كل الكلمات إلى أحرف صغيرة أو كبيرة قبل المقارنة."]}], "tstamp": 1756212524.6298025}
{"question_id": 72, "answer_id": "Go6aTHKWMXZJ9HbhdeRUsT", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["بالطبع، هنا هو الكود الذي يمكنك استخدامه للعثور على أطول تسلسل فرعي مشترك باستخدام البرمجة الديناميكية في Python:\n\n```python\ndef lcs(X , Y): \n    m = len(X) \n    n = len(Y) \n  \n    L = [[None]*(n+1) for i in range(m+1)] \n  \n    for i in range(m+1): \n        for j in range(n+1): \n            if i == 0 or j == 0 : \n                L[i][j] = 0\n            elif X[i-1] == Y[j-1]: \n                L[i][j] = L[i-1][j-1]+1\n            else: \n                L[i][j] = max(L[i-1][j] , L[i][j-1]) \n  \n    return L[m][n] \n```\n\nفي هذا الكود، `X` و `Y` هما السلاسل التي تريد البحث عن أطول تسلسل فرعي مشترك بينهما. الدالة `lcs` تقوم بإنشاء جدول `L` ثنائي الأبعاد يحتوي على الأطوال القصوى للتسلسلات الفرعية المشتركة لجميع الأزواج الممكنة من السلاسل الفرعية لـ `X` و `Y`. ثم تقوم بإرجاع الطول الأقصى للتسلسل الفرعي المشترك بين `X` و `Y`."]}], "tstamp": 1756212539.0477583}
{"question_id": 73, "answer_id": "bdGQyZUJrUj9rvZMWwbNeN", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["بالطبع، يمكنك استخدام الوحدة النمطية `re` في Python للتحقق من صحة عناوين البريد الإلكتروني باستخدام التعبيرات العادية. هنا هو كيف يمكنك القيام بذلك:\n\n```python\nimport re\n\ndef validate_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n\n# تجربة الدالة\nprint(validate_email(\"example@example.com\"))  # يجب أن يعود True\nprint(validate_email(\"example\"))  # يجب أن يعود False\n```\n\nهذا الكود يعرف دالة تسمى `validate_email` تأخذ عنوان بريد إلكتروني كمدخلات وترجع `True` إذا كان البريد الإلكتروني صالحًا و `False` إذا لم يكن كذلك. البريد الإلكتروني يعتبر صالحًا إذا كان يتوافق مع النمط المحدد في الدالة، والذي يتطلب وجود حروف أو أرقام أو نقاط أو شرطات أو علامات + أو _ قبل علامة @، تليها المزيد من الحروف أو الأرقام أو النقاط أو الشرطات، وأخيرًا نقطة ومزيد من الحروف أو الأرقام أو النقاط."]}], "tstamp": 1756212555.8136716}
{"question_id": 74, "answer_id": "NqDjVweqLkMVN49RcLpihJ", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["بالطبع، هنا هو برنامج بسيط بلغة Python يستخدم البرمجة الديناميكية للعثور على العدد الفيبوناتشي n:\n\n```python\ndef fibonacci(n):\n    fib_values = [0, 1]\n    \n    while len(fib_values) < n + 1: \n        fib_values.append(0)\n  \n    if n <= 1: \n       return n \n    else: \n       if fib_values[n - 1] == 0: \n           fib_values[n - 1] = fibonacci(n - 1) \n  \n       if fib_values[n - 2] == 0: \n           fib_values[n - 2] = fibonacci(n - 2) \n      \n       fib_values[n] = fib_values[n - 2] + fib_values[n - 1] \n    return fib_values[n] \n\nn = int(input(\"أدخل الرقم: \"))\nprint(fibonacci(n))\n```\n\nفي هذا البرنامج، نحن نستخدم قائمة `fib_values` لتخزين القيم الفيبوناتشي التي حسبناها بالفعل، بحيث لا نحتاج إلى إعادة حسابها في المستقبل. هذا هو الجزء الأساسي من البرمجة الديناميكية."]}], "tstamp": 1756212568.1019142}
{"question_id": 75, "answer_id": "dLFbFKtzVPTVgJmYdqTHMb", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["البحث الثنائي هو خوارزمية بحث فعالة تستخدم في البحث عن عنصر محدد في مصفوفة مرتبة. الخوارزمية تعمل على مبدأ تقسيم وحكم، حيث تقسم المصفوفة المرتبة إلى نصفين في كل خطوة وتقارن العنصر المركزي بالعنصر المطلوب. إذا كان العنصر المركزي أصغر، فإنها تتجاهل النصف الأيسر من المصفوفة وتكرر العملية على النصف الأيمن، والعكس صحيح.\n\nالخوارزمية بلغة البرمجة Python:\n\n```python\ndef binary_search(arr, low, high, x):\n \n    if high >= low:\n \n        mid = (high + low) // 2\n \n        if arr[mid] == x:\n            return mid\n \n        elif arr[mid] > x:\n            return binary_search(arr, low, mid - 1, x)\n \n        else:\n            return binary_search(arr, mid + 1, high, x)\n \n    else:\n        return -1\n \narr = [2, 3, 4, 10, 40]\nx = 10\n \nresult = binary_search(arr, 0, len(arr)-1, x)\n \nif result != -1:\n    print(\"Element is present at index\", str(result))\nelse:\n    print(\"Element is not present in array\")\n```\n\nفي هذا البرنامج، يتم تمرير المصفوفة المرتبة `arr`، الفهرس الأدنى `low`، الفهرس الأعلى `high`، والعنصر المطلوب `x` إلى الدالة `binary_search`. الدالة تقوم بإرجاع الفهرس الذي يحتوي على العنصر المطلوب، أو `-1` إذا لم يكن العنصر موجودًا في المصفوفة."]}], "tstamp": 1756212587.3750417}
{"question_id": 76, "answer_id": "kPKGHfkkDYupFDaXSCCFD6", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["قائمة الانتظار هي بنية بيانات تتبع مبدأ FIFO (الأول في الداخل هو الأول في الخروج). يمكننا تنفيذ هذه البنية باستخدام قائمتين في Python. الرمز التالي يوضح كيفية القيام بذلك:\n\n```python\nclass Queue:\n    def __init__(self):\n        self.in_stack = []\n        self.out_stack = []\n\n    def enqueue(self, item):\n        # إضافة عنصر إلى القائمة\n        self.in_stack.append(item)\n\n    def dequeue(self):\n        # إذا كانت القائمة الثانية فارغة، نقوم بنقل العناصر من القائمة الأولى\n        if not self.out_stack:\n            while self.in_stack:\n                # نقل العناصر من القائمة الأولى إلى الثانية\n                self.out_stack.append(self.in_stack.pop())\n        # إزالة العنصر الأول من القائمة الثانية\n        return self.out_stack.pop()\n\n# تجربة القائمة\nqueue = Queue()\nqueue.enqueue('a')\nqueue.enqueue('b')\nqueue.enqueue('c')\nprint(queue.dequeue())  # يجب أن يطبع 'a'\nprint(queue.dequeue())  # يجب أن يطبع 'b'\n```\n\nفي هذا الرمز، نستخدم قائمتين: in_stack و out_stack. عندما نضيف عنصر، نضيفه إلى in_stack. عندما نريد إزالة عنصر، نقوم بإزالته من out_stack. إذا كانت out_stack فارغة، نقوم بنقل جميع العناصر من in_stack إلى out_stack."]}], "tstamp": 1756212601.054371}
{"question_id": 77, "answer_id": "QbzdH5eEmEMRCSBY5Sw2oo", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["بالطبع، يمكنك استخدام البرمجة بلغة Python للقيام بذلك. هنا هو برنامج بسيط يقوم بالعمل:\n\n```python\ndef find_common_elements(array1, array2):\n    common_elements = []\n\n    for i in array1:\n        if i in array2:\n            common_elements.append(i)\n\n    return common_elements\n\n# تجربة البرنامج\narray1 = [1, 2, 3, 4, 5]\narray2 = [4, 5, 6, 7, 8]\nprint(find_common_elements(array1, array2))  # يجب أن يطبع [4, 5]\n```\n\nهذا البرنامج يقوم بتكرار على كل عنصر في الصفيف الأول، ويتحقق إذا كان هذا العنصر موجودا في الصفيف الثاني. إذا كان العنصر موجودا، يتم إضافته إلى قائمة العناصر المشتركة.\n\nيرجى ملاحظة أن هذا البرنامج ليس فعالا من حيث الأداء إذا كانت المصفوفتين كبيرتين جدا، لأنه يتطلب تكرار على كل عنصر في الصفيف الأول لكل عنصر في الصفيف الثاني، مما يعني أن البرنامج يستغرق وقتا يتناسب مع حاصل ضرب حجم الصفيفين."]}], "tstamp": 1756212620.6339116}
{"question_id": 78, "answer_id": "CasQ3AtxjLHcgwRfTMSP7S", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["لحساب قيمة f(2)، نحتاج إلى استبدال x في المعادلة بـ 2.\n\nf(2) = 5(2)^3 - 2(2) + 3\n     = 5(8) - 4 + 3\n     = 40 - 4 + 3\n     = 39\n\nإذاً، f(2) = 39."]}], "tstamp": 1756212625.936951}
{"question_id": 79, "answer_id": "fC6BqKQEtjxDBrNnaezqAw", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["لحل المعادلة، نبدأ بتوزيع القيمة 5 على كل من x و -2 في الجانب الأيمن من المعادلة:\n\n3x + 10 = 5x - 10\n\nثم نقوم بنقل القيم المتشابهة إلى الجانبين المقابلين للمعادلة:\n\n3x - 5x = -10 - 10\n\nوالذي يعطينا:\n\n-2x = -20\n\nوأخيراً، نقسم كلا الجانبين على -2 للحصول على قيمة x:\n\nx = -20 / -2\n\nوبالتالي، القيمة المطلوبة لـ x هي 10."]}], "tstamp": 1756212633.469718}
{"question_id": 80, "answer_id": "Xs6f5JkttBAFz4ZtUqYQV2", "model_id": "gpt-4", "choices": [{"index": 0, "turns": ["لحساب طول القطعة الخطية بين نقطتين، يمكننا استخدام الصيغة التالية:\n\nd = √[(x_2-x_1)² + (y_2-y_1)²]\n\nحيث (x_1, y_1) هي النقطة الأولى و (x_2, y_2) هي النقطة الثانية.\n\nفي هذه الحالة، (x_1, y_1) هي (2, -2) و (x_2, y_2) هي (10, 4).\n\nإذاً، الطول d هو:\n\nd = √[(10-2)² + (4-(-2))²]\n= √[(8)² + (6)²]\n= √[64 + 36]\n= √100\n= 10\n\nإذاً، طول القطعة الخطية هو 10."]}], "tstamp": 1756212641.471728}
