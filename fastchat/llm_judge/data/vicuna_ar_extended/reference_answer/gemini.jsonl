{"question_id": 71, "answer_id": "0a98b07646e7422789c69270c3a66386", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد، هذا برنامج C++ كامل يقوم بقراءة ملف نصي، ويحسب عدد مرات ظهور كلمة معينة يحددها المستخدم. البرنامج يحتوي على تعليقات لشرح كل جزء.\n\n### الكود البرمجي (main.cpp)\n\n```cpp\n#include <iostream>\n#include <fstream>   // للتعامل مع الملفات\n#include <string>    // لاستخدام نوع البيانات string\n#include <sstream>   // لاستخدام stringstream لتحليل السطور\n\nint main() {\n    // تعريف المتغيرات\n    std::string filename;      // لتخزين اسم الملف\n    std::string wordToSearch;  // الكلمة المراد البحث عنها\n    int count = 0;             // عداد لتخزين عدد مرات ظهور الكلمة\n\n    // طلب المعلومات من المستخدم\n    std::cout << \"ادخل اسم الملف (e.g., data.txt): \";\n    std::cin >> filename;\n\n    std::cout << \"ادخل الكلمة التي تريد البحث عنها: \";\n    std::cin >> wordToSearch;\n\n    // إنشاء كائن لفتح الملف للقراءة\n    std::ifstream inputFile(filename);\n\n    // التحقق مما إذا كان الملف قد تم فتحه بنجاح\n    if (!inputFile.is_open()) {\n        std::cerr << \"خطأ: لم نتمكن من فتح الملف '\" << filename << \"'\" << std::endl;\n        return 1; // الخروج من البرنامج مع رمز خطأ\n    }\n\n    std::string line;\n    // قراءة الملف سطراً بسطر حتى نهاية الملف\n    while (std::getline(inputFile, line)) {\n        // إنشاء stringstream من السطر الحالي لتسهيل استخراج الكلمات\n        std::stringstream ss(line);\n        std::string word;\n\n        // استخراج كل كلمة من السطر\n        while (ss >> word) {\n            // ملاحظة: هذه المقارنة حساسة لحالة الأحرف.\n            // لجعلها غير حساسة، يجب تحويل الكلمتين إلى حالة أحرف موحدة (صغيرة أو كبيرة) قبل المقارنة.\n            if (word == wordToSearch) {\n                count++; // زيادة العداد إذا تطابقت\n            }\n        }\n    }\n\n    // إغلاق الملف بعد الانتهاء\n    inputFile.close();\n\n    // طباعة النتيجة النهائية\n    std::cout << \"\\nالكلمة '\" << wordToSearch << \"' ظهرت \" << count << \" مرة في الملف.\" << std::endl;\n\n    return 0; // إشارة إلى أن البرنامج انتهى بنجاح\n}\n```\n\n### كيفية الاستخدام:\n\n1.  **إنشاء ملف نصي:** قم بإنشاء ملف نصي بنفس مجلد الكود، وسمّه على سبيل المثال `data.txt` وضع فيه المحتوى التالي:\n\n    ```text\n    مرحبا يا عالم\n    هذا اختبار بسيط لعد الكلمات في هذا الملف\n    البرمجة عالم ممتع عالم جميل\n    ```\n\n2.  **حفظ الكود:** احفظ الكود أعلاه في ملف باسم `main.cpp`.\n\n3.  **ترجمة (Compile) الكود:** افتح الطرفية (Terminal) أو موجه الأوامر (Command Prompt) في مجلد المشروع ونفذ الأمر التالي (تحتاج إلى مترجم C++ مثل g++):\n\n    ```sh\n    g++ main.cpp -o word_counter\n    ```\n\n4.  **تشغيل البرنامج:** قم بتشغيل الملف التنفيذي الناتج:\n\n    ```sh\n    ./word_counter\n    ```\n\n5.  **التفاعل مع البرنامج:** سيطلب منك البرنامج إدخال اسم الملف والكلمة. مثال:\n\n    ```text\n    ادخل اسم الملف (e.g., data.txt): data.txt\n    ادخل الكلمة التي تريد البحث عنها: عالم\n    ```\n\n### الخرج المتوقع:\n\nبناءً على ملف `data.txt` والمدخلات أعلاه، ستكون النتيجة:\n\n```text\nالكلمة 'عالم' ظهرت 3 مرة في الملف.\n```"]}], "tstamp": 1757419547.1591954}
{"question_id": 72, "answer_id": "a2ac96c29d2447f69c37e4b5994e5a86", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["def longest_common_subsequence(s1, s2):\n    m = len(s1)\n    n = len(s2)\n\n    # إنشاء جدول البرمجة الديناميكية لتخزين أطوال أطول التسلسلات الفرعية المشتركة.\n    # dp[i][j] سيخزن طول أطول تسلسل فرعي مشترك لـ s1[0..i-1] و s2[0..j-1]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # بناء جدول dp بطريقة تصاعدية\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # إعادة بناء سلسلة أطول تسلسل فرعي مشترك عن طريق التتبع الخلفي\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        # إذا تطابق الحرفان، فإنهما جزء من أطول تسلسل فرعي مشترك\n        if s1[i - 1] == s2[j - 1]:\n            lcs.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        # إذا لم يتطابقا، تحرك في اتجاه التسلسل الفرعي الأطول\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # تم بناء السلسلة بشكل عكسي، لذا يجب عكسها للحصول على الترتيب الصحيح\n    return \"\".join(reversed(lcs))"]}], "tstamp": 1757419547.1592386}
{"question_id": 73, "answer_id": "989994063c574bfca32fb8c678aa94fa", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد، يمكنك استخدام وحدة `re` في بايثون للتحقق من صحة عناوين البريد الإلكتروني. إليك مثال عملي مع شرح للتعبير العادي المستخدم:\n\n```python\nimport re\n\n# تعبير عادي للتحقق من صحة البريد الإلكتروني\n# هذا التعبير يغطي الحالات الشائعة ولكنه قد لا يغطي كل الحالات النادرة الممكنة.\nregex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n\ndef is_valid_email(email):\n    \"\"\"تتحقق هذه الدالة مما إذا كان البريد الإلكتروني متوافقًا مع التعبير العادي.\"\"\"\n    if re.fullmatch(regex, email):\n        return True\n    else:\n        return False\n\n# --- أمثلة للاستخدام ---\n\n# بريد إلكتروني صحيح\nemail1 = \"test.user@example.com\"\nif is_valid_email(email1):\n    print(f\"'{email1}' هو عنوان بريد إلكتروني صالح.\")\nelse:\n    print(f\"'{email1}' هو عنوان بريد إلكتروني غير صالح.\")\n\n# بريد إلكتروني غير صحيح (يفتقد لـ @)\nemail2 = \"invalid-email.com\"\nif is_valid_email(email2):\n    print(f\"'{email2}' هو عنوان بريد إلكتروني صالح.\")\nelse:\n    print(f\"'{email2}' هو عنوان بريد إلكتروني غير صالح.\")\n\n# بريد إلكتروني غير صحيح (يفتقد للنطاق العلوي)\nemail3 = \"user@domain\"\nif is_valid_email(email3):\n    print(f\"'{email3}' هو عنوان بريد إلكتروني صالح.\")\nelse:\n    print(f\"'{email3}' هو عنوان بريد إلكتروني غير صالح.\")\n```\n\n### شرح التعبير العادي `(regex)`:\n\n- `^`: يطابق بداية السلسلة النصية.\n- `[a-zA-Z0-9._%+-]+`: هذا هو الجزء الخاص باسم المستخدم (قبل الـ `@`). يسمح بالحروف (كبيرة وصغيرة)، الأرقام، والرموز `.` `_` `%` `+` `-`. علامة `+` تعني أن الرمز السابق يجب أن يظهر مرة واحدة على الأقل.\n- `@`: يطابق رمز `@` حرفيًا.\n- `[a-zA-Z0-9.-]+`: هذا هو الجزء الخاص باسم النطاق (domain). يسمح بالحروف، الأرقام، والنقطة `.` والشرطة `-`.\n- `\\.`: يطابق النقطة `.` حرفيًا التي تفصل اسم النطاق عن النطاق العلوي. الشرطة المائلة `\\` ضرورية لأن النقطة لها معنى خاص في التعابير العادية.\n- `[a-zA-Z]{2,}`: هذا هو الجزء الخاص بالنطاق العلوي (مثل com, net, org). يسمح بالحروف فقط ويجب أن يكون طوله حرفين على الأقل.\n- `$`: يطابق نهاية السلسلة النصية.\n\nاستخدام `re.fullmatch` يضمن أن السلسلة النصية **بأكملها** تتطابق مع النمط، وهو الأنسب لعمليات التحقق من الصحة."]}], "tstamp": 1757419547.1592872}
{"question_id": 74, "answer_id": "d1d3f9aed8324ae0a97a188425a78241", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد. إليك برنامج بايثون يستخدم البرمجة الديناميكية بأسلوب الجدولة (Tabulation / Bottom-up) لإيجاد العدد الفيبوناتشي رقم `n` بكفاءة.\n\nهذا الأسلوب يتجنب الحسابات المتكررة الموجودة في الحل العودي البسيط عن طريق بناء الحل من الحالات الأساسية (F(0) و F(1)) وصولًا إلى العدد المطلوب `n`، مع تخزين كل نتيجة وسيطة في مصفوفة.\n\n```python\ndef fibonacci_dynamic(n):\n    \"\"\"\n    تحسب هذه الدالة العدد الفيبوناتشي رقم n باستخدام البرمجة الديناميكية (أسلوب الجدولة).\n    \"\"\"\n    # التعامل مع المدخلات غير الصحيحة أو الحالات الأساسية الأولى\n    if n < 0:\n        raise ValueError(\"المدخل يجب أن يكون عددًا صحيحًا غير سالب\")\n    if n <= 1:\n        return n\n\n    # إنشاء جدول (مصفوفة) لتخزين النتائج المحسوبة\n    # حجم الجدول هو n+1 لاستيعاب الفهرس من 0 إلى n\n    dp_table = [0] * (n + 1)\n\n    # تحديد الحالات الأساسية في الجدول\n    dp_table[1] = 1\n\n    # بناء الجدول بشكل تكراري من الأسفل إلى الأعلى\n    for i in range(2, n + 1):\n        # كل قيمة فيبوناتشي هي مجموع القيمتين السابقتين لها\n        dp_table[i] = dp_table[i - 1] + dp_table[i - 2]\n\n    # النتيجة النهائية موجودة في نهاية الجدول\n    return dp_table[n]\n\n# --- مثال على الاستخدام ---\n\n# العدد الذي نريد حساب الفيبوناتشي له\nnumero = 10\n\n# استدعاء الدالة وطباعة النتيجة\ntry:\n    resultado = fibonacci_dynamic(numero)\n    print(f\"العدد الفيبوناتشي رقم {numero} هو: {resultado}\")\nexcept ValueError as e:\n    print(e)\n\n\n# مثال آخر\nnumero_2 = 15\ntry:\n    resultado_2 = fibonacci_dynamic(numero_2)\n    print(f\"العدد الفيبوناتشي رقم {numero_2} هو: {resultado_2}\")\nexcept ValueError as e:\n    print(e)\n\n# الإخراج المتوقع:\n# العدد الفيبوناتشي رقم 10 هو: 55\n# العدد الفيبوناتشي رقم 15 هو: 610\n```\n\n**كيف يعمل الكود:**\n1.  **التحقق من المدخلات:** يتأكد أولاً من أن `n` ليس عددًا سالبًا ويعالج الحالات الأساسية `n=0` و `n=1`.\n2.  **إنشاء الجدول (`dp_table`):** يتم إنشاء قائمة بحجم `n+1` لتخزين قيم فيبوناتشي. `dp_table[i]` سيحتوي على قيمة `fib(i)`.\n3.  **ملء الحالات الأساسية:** يتم وضع `dp_table[1] = 1` (بينما `dp_table[0]` هو بالفعل 0).\n4.  **الحلقة التكرارية:** تبدأ الحلقة من `i = 2` وتستمر حتى `n`. في كل خطوة، تحسب `dp_table[i]` عن طريق جمع القيمتين السابقتين (`dp_table[i-1]` و `dp_table[i-2]`) اللتين تم حسابهما بالفعل.\n5.  **النتيجة النهائية:** بعد انتهاء الحلقة، تكون القيمة `fib(n)` مخزنة في `dp_table[n]`، والتي يتم إرجاعها."]}], "tstamp": 1757419547.1593208}
{"question_id": 75, "answer_id": "6e1f36ac21814307b963be4bcbc79154", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد، إليك تنفيذ خوارزمية البحث الثنائي (Binary Search) باستخدام لغة بايثون، مع شرح للخطوات بالعربية.\n\n**الفكرة الأساسية للخوارزمية:**\n\nالبحث الثنائي هي خوارزمية فعالة جدًا للعثور على عنصر في **مصفوفة مرتبة**. تعمل عن طريق مقارنة العنصر المستهدف مع العنصر الأوسط في المصفوفة بشكل متكرر. إذا لم يكن العنصر الأوسط هو العنصر المستهدف، يتم التخلص من نصف المصفوفة الذي لا يمكن أن يحتوي على العنصر، ويستمر البحث في النصف المتبقي حتى يتم العثور على العنصر أو يتبقى جزء فارغ للبحث فيه.\n\n**الكود بلغة بايثون:**\n\n```python\ndef binary_search(arr, target):\n    \"\"\"\n    دالة لتنفيذ خوارزمية البحث الثنائي.\n    :param arr: قائمة (مصفوفة) مرتبة من العناصر.\n    :param target: العنصر المراد البحث عنه.\n    :return: مؤشر (index) العنصر إذا تم العثور عليه، وإلا -1.\n    \"\"\"\n    low = 0  # مؤشر بداية النطاق\n    high = len(arr) - 1  # مؤشر نهاية النطاق\n\n    while low <= high:\n        # حساب المؤشر الأوسط لتجنب الفائض (overflow) في لغات أخرى\n        mid = low + (high - low) // 2\n\n        # التحقق مما إذا كان العنصر المستهدف موجودًا في المنتصف\n        if arr[mid] == target:\n            return mid\n\n        # إذا كان العنصر المستهدف أكبر من العنصر الأوسط، تجاهل النصف الأيسر\n        elif arr[mid] < target:\n            low = mid + 1\n\n        # إذا كان العنصر المستهدف أصغر من العنصر الأوسط، تجاهل النصف الأيمن\n        else:\n            high = mid - 1\n\n    # إذا وصلنا إلى هنا، فالعنصر غير موجود في المصفوفة\n    return -1\n\n# --- مثال على الاستخدام ---\n\n# مصفوفة مرتبة\nmy_array = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n\n# العنصر الذي نريد البحث عنه\nelement_to_find = 23\n\n# استدعاء الدالة\nresult = binary_search(my_array, element_to_find)\n\nif result != -1:\n    print(f\"تم العثور على العنصر '{element_to_find}' في الموقع (index): {result}\")\nelse:\n    print(f\"العنصر '{element_to_find}' غير موجود في المصفوفة.\")\n\n\n# مثال آخر: البحث عن عنصر غير موجود\nelement_to_find_2 = 15\nresult_2 = binary_search(my_array, element_to_find_2)\n\nif result_2 != -1:\n    print(f\"تم العثور على العنصر '{element_to_find_2}' في الموقع (index): {result_2}\")\nelse:\n    print(f\"العنصر '{element_to_find_2}' غير موجود في المصفوفة.\")\n\n```\n\n**شرح خطوات التنفيذ في المثال الأول (البحث عن 23):**\n\n1.  **المصفوفة:** `[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]`\n2.  **الخطوة 1:**\n    *   `low = 0`, `high = 9`\n    *   `mid = (0 + 9) // 2 = 4`. العنصر في `arr[4]` هو `16`.\n    *   `16 < 23`، لذا يتم تجاهل النصف الأيسر. `low` يصبح `mid + 1 = 5`.\n3.  **الخطوة 2:**\n    *   `low = 5`, `high = 9`\n    *   `mid = (5 + 9) // 2 = 7`. العنصر في `arr[7]` هو `56`.\n    *   `56 > 23`، لذا يتم تجاهل النصف الأيمن. `high` يصبح `mid - 1 = 6`.\n4.  **الخطوة 3:**\n    *   `low = 5`, `high = 6`\n    *   `mid = (5 + 6) // 2 = 5`. العنصر في `arr[5]` هو `23`.\n    *   `23 == 23`. تم العثور على العنصر.\n5.  **النتيجة:** الدالة تُرجع المؤشر `5`."]}], "tstamp": 1757419547.159364}
{"question_id": 76, "answer_id": "7232064bf4184b7a88d457dcf81a1f73", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد. إليك كيفية تنفيذ بنية قائمة انتظار (Queue) باستخدام كومتين (Stacks) في لغة بايثون. الفكرة الأساسية هي استخدام كومة لعمليات الإضافة (enqueue) وكومة أخرى لعمليات الحذف (dequeue).\n\n### المبدأ\n1.  **كومة الإضافة (stack1):** عند إضافة عنصر جديد، يتم دفعه (push) ببساطة إلى هذه الكومة.\n2.  **كومة الحذف (stack2):** عند طلب عنصر (dequeue)، نتحقق أولاً من هذه الكومة.\n    *   إذا كانت `stack2` **غير فارغة**، فإن العنصر الموجود في قمتها هو أقدم عنصر تم إدخاله، لذلك نقوم بسحبه (pop) وإرجاعه مباشرة.\n    *   إذا كانت `stack2` **فارغة**، نقوم بنقل جميع العناصر من `stack1` إلى `stack2`. هذه العملية تعكس ترتيب العناصر، فتجعل العنصر الذي كان في أسفل `stack1` (أقدم عنصر) في قمة `stack2`. بعد ذلك، نسحب العنصر من قمة `stack2`.\n\nبهذه الطريقة، نضمن دائمًا أننا نزيل أقدم عنصر، محققين بذلك مبدأ \"من يدخل أولاً يخرج أولاً\" (FIFO).\n\n### الكود في بايثون\n\n```python\nclass QueueUsingTwoStacks:\n    \"\"\"تنفيذ قائمة انتظار (Queue) باستخدام قائمتين تعملان ككومة (Stack).\"\"\"\n    def __init__(self):\n        # الكومة الأولى مخصصة لعمليات الإضافة (enqueue)\n        self.stack1 = []\n        # الكومة الثانية مخصصة لعمليات الحذف (dequeue)\n        self.stack2 = []\n\n    def enqueue(self, item):\n        \"\"\"إضافة عنصر إلى نهاية قائمة الانتظار.\"\"\"\n        self.stack1.append(item)\n\n    def _transfer_if_needed(self):\n        \"\"\"دالة مساعدة لنقل العناصر من stack1 إلى stack2 إذا كانت stack2 فارغة.\"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n\n    def dequeue(self):\n        \"\"\"إزالة وإرجاع العنصر من بداية قائمة الانتظار.\"\"\"\n        self._transfer_if_needed()\n        if not self.stack2:\n            # إذا كانت الكومتان فارغتين، فالقائمة فارغة\n            raise IndexError(\"dequeue from empty queue\")\n        # إرجاع العنصر العلوي من الكومة الثانية (وهو أقدم عنصر)\n        return self.stack2.pop()\n\n    def peek(self):\n        \"\"\"إلقاء نظرة على العنصر الأول في قائمة الانتظار دون إزالته.\"\"\"\n        self._transfer_if_needed()\n        if not self.stack2:\n            raise IndexError(\"peek from empty queue\")\n        # إرجاع العنصر العلوي دون حذفه\n        return self.stack2[-1]\n\n    def is_empty(self):\n        \"\"\"التحقق مما إذا كانت قائمة الانتظار فارغة.\"\"\"\n        return not self.stack1 and not self.stack2\n\n    def size(self):\n        \"\"\"إرجاع عدد العناصر الإجمالي في قائمة الانتظار.\"\"\"\n        return len(self.stack1) + len(self.stack2)\n\n# --- مثال على الاستخدام ---\n\n# إنشاء كائن جديد من القائمة\nq = QueueUsingTwoStacks()\n\n# إضافة عناصر إلى القائمة\nprint(\"إضافة العناصر: 10, 20, 30\")\nq.enqueue(10)\nq.enqueue(20)\nq.enqueue(30)\n\nprint(f\"حجم القائمة الآن: {q.size()}\")  # الناتج: 3\n\n# إلقاء نظرة على العنصر الأول (يجب أن يكون 10)\nprint(f\"العنصر الأول في القائمة (peek): {q.peek()}\")  # الناتج: 10\n\n# حذف العناصر بالترتيب (يجب أن تخرج 10, ثم 20, ثم 30)\nprint(\"حذف العناصر من القائمة:\")\nprint(f\"تم حذف: {q.dequeue()}\")  # الناتج: 10\nprint(f\"تم حذف: {q.dequeue()}\")  # الناتج: 20\n\nprint(f\"حجم القائمة الآن: {q.size()}\")  # الناتج: 1\n\n# إضافة عنصر جديد\nprint(\"إضافة العنصر: 40\")\nq.enqueue(40)\n\nprint(f\"تم حذف: {q.dequeue()}\")  # الناتج: 30\nprint(f\"تم حذف: {q.dequeue()}\")  # الناتج: 40\n\nprint(f\"هل القائمة فارغة الآن؟ {q.is_empty()}\") # الناتج: True\n\n```"]}], "tstamp": 1757419547.1593933}
{"question_id": 77, "answer_id": "e15bf9d3c78b4cc7b8dd33fbc6cb4644", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد. لإيجاد العناصر المشتركة في مصفوفتين دون استخدام هياكل بيانات إضافية (مثل Set أو Dictionary)، يمكن استخدام طريقتين رئيسيتين. الطريقة الثانية هي الأكثر كفاءة.\n\n### الطريقة الأولى: الحلقات المتداخلة (Brute Force)\n\nتعتمد هذه الطريقة على المرور على كل عنصر في المصفوفة الأولى ومقارنته مع كل عنصر في المصفوفة الثانية.\n\n**الخطوات:**\n1. إنشاء قائمة فارغة للنتائج `common_elements`.\n2. المرور على كل عنصر `elem1` في المصفوفة الأولى.\n3. داخل هذه الحلقة، يتم المرور على كل عنصر `elem2` في المصفوفة الثانية.\n4. إذا كان `elem1` يساوي `elem2`، يتم إضافة العنصر إلى قائمة النتائج (مع التحقق من عدم وجوده مسبقًا لتجنب التكرار).\n\n**مثال بلغة Python:**\n```python\ndef find_common_brute_force(arr1, arr2):\n    common_elements = []\n    for elem1 in arr1:\n        for elem2 in arr2:\n            if elem1 == elem2:\n                # أضف العنصر فقط إذا لم يكن موجودًا بالفعل لتجنب التكرار\n                if elem1 not in common_elements:\n                    common_elements.append(elem1)\n    return common_elements\n\n# مثال للتجربة\narray1 = [1, 2, 3, 4, 5, 4]\narray2 = [4, 5, 6, 7, 8, 5]\nprint(f\"العناصر المشتركة (بالقوة الغاشمة): {find_common_brute_force(array1, array2)}\")\n# المخرجات: [4, 5]\n```\n**العيوب:** هذه الطريقة بطيئة جدًا للمصفوفات الكبيرة، حيث أن تعقيدها الزمني هو O(n * m).\n\n---\n\n### الطريقة الثانية: الفرز واستخدام مؤشرين (Sort and Two Pointers)\n\nهذه الطريقة أكثر كفاءة بكثير. تعتمد على فرز المصفوفتين أولاً، ثم مقارنة عناصرهما في مسار واحد.\n\n**الخطوات:**\n1. قم بفرز (ترتيب) كل من المصفوفتين تصاعديًا.\n2. عرّف مؤشرين، `i` للمصفوفة الأولى و `j` للثانية، وكلاهما يبدأ من الصفر.\n3. استمر في المرور طالما أن المؤشرين لم يتجاوزا حدود المصفوفتين.\n4. قارن بين `arr1[i]` و `arr2[j]`:\n   - إذا كان `arr1[i]` أصغر من `arr2[j]`، قم بزيادة `i`.\n   - إذا كان `arr1[i]` أكبر من `arr2[j]`، قم بزيادة `j`.\n   - إذا كانا متساويين، فهذا عنصر مشترك. أضفه إلى قائمة النتائج، ثم قم بزيادة كلا المؤشرين `i` و `j`.\n\n**مثال بلغة Python:**\n```python\ndef find_common_sorted(arr1, arr2):\n    # أولاً، قم بفرز المصفوفتين\n    arr1.sort()\n    arr2.sort()\n\n    common_elements = []\n    i = 0\n    j = 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr1[i] > arr2[j]:\n            j += 1\n        else: # العناصر متساوية\n            # أضف العنصر إذا لم يكن هو نفسه العنصر الأخير الذي تمت إضافته\n            if not common_elements or common_elements[-1] != arr1[i]:\n                common_elements.append(arr1[i])\n            i += 1\n            j += 1\n            \n    return common_elements\n\n# مثال للتجربة\narray1 = [4, 9, 5, 1]\narray2 = [9, 4, 9, 8, 4]\nprint(f\"العناصر المشتركة (بالفرز والمؤشرين): {find_common_sorted(array1, array2)}\")\n# المخرجات: [4, 9]\n```\n**المميزات:** هذه الطريقة أسرع بكثير للمصفوفات الكبيرة. تعقيدها الزمني يعتمد بشكل أساسي على عملية الفرز، وهو O(n log n + m log m)."]}], "tstamp": 1757419547.1594424}
{"question_id": 78, "answer_id": "388f466128af44a18663aaf3f495feb9", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["لحساب قيمة f(2)، نعوض x بـ 2 في الدالة:\n\nf(2) = 5(2)^3 - 2(2) + 3\n\n1. نحسب القوة أولاً: 2^3 = 8\nf(2) = 5(8) - 2(2) + 3\n\n2. ثم نقوم بعمليات الضرب:\nf(2) = 40 - 4 + 3\n\n3. وأخيرًا، نقوم بالجمع والطرح:\nf(2) = 36 + 3\nf(2) = 39\n\nإذًا، قيمة f(2) هي 39."]}], "tstamp": 1757419547.1594696}
{"question_id": 79, "answer_id": "49877bccde1d4923bee103130ac3187a", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["لحل المعادلة 3x + 10 = 5(x - 2)، اتبع الخطوات التالية:\n1. فك القوس في الطرف الأيمن: 3x + 10 = 5x - 10\n2. اجمع الحدود التي تحتوي على x في طرف واحد والثوابت في الطرف الآخر: 10 + 10 = 5x - 3x\n3. بسّط المعادلة: 20 = 2x\n4. اقسم كلا الطرفين على 2 لإيجاد قيمة x:\nx = 10\nإذًا، قيمة x هي 10."]}], "tstamp": 1757419547.1594808}
{"question_id": 80, "answer_id": "c0902406ed564783866da202d25f4b45", "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["طول القطعة الخطية هو 10 وحدات."]}], "tstamp": 1757419547.1594915}
