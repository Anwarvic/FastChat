{"question_id": 71, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد، إليك برنامج C++ يقوم بقراءة ملف نصي سطرًا بسطر ويحسب عدد المرات التي تظهر فيها كلمة معينة.\n\nلجعل البرنامج يعمل، اتبع الخطوات التالية:\n\nإنشاء ملف الكود المصدري: قم بإنشاء ملف جديد باسم word_counter.cpp والصق الكود أدناه فيه.\n\nإنشاء ملف نصي: في نفس المجلد، قم بإنشاء ملف نصي (على سبيل المثال، input.txt) يحتوي على النص الذي تريد تحليله.\n\nالترجمة والتشغيل: قم بترجمة وتشغيل برنامج C++. سيُطلب منك إدخال اسم الملف النصي والكلمة التي تريد البحث عنها.\n\nالكود البرمجي\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <sstream>\n\nint main() {\n    std::string fileName;\n    std::string wordToSearch;\n    int wordCount = 0;\n\n    // اطلب من المستخدم إدخال اسم الملف والكلمة\n    std::cout << \"أدخل اسم الملف: \";\n    std::cin >> fileName;\n    std::cout << \"أدخل الكلمة للبحث عنها: \";\n    std::cin >> wordToSearch;\n\n    // افتح الملف للقراءة\n    std::ifstream inputFile(fileName);\n\n    // تحقق مما إذا كان الملف مفتوحًا بنجاح\n    if (!inputFile.is_open()) {\n        std::cerr << \"خطأ: لم يتمكن من فتح الملف \" << fileName << std::endl;\n        return 1; // إنهاء البرنامج مع رمز خطأ\n    }\n\n    std::string line;\n    // اقرأ الملف سطراً بسطر\n    while (std::getline(inputFile, line)) {\n        std::stringstream ss(line);\n        std::string word;\n        // استخرج كل كلمة من السطر\n        while (ss >> word) {\n            // قارن الكلمة المستخرجة بالكلمة المطلوبة\n            if (word == wordToSearch) {\n                wordCount++;\n            }\n        }\n    }\n\n    // أغلق الملف\n    inputFile.close();\n\n    // اطبع النتيجة\n    std::cout << \"الكلمة '\" << wordToSearch << \"' ظهرت \" << wordCount << \" مرة في الملف.\" << std::endl;\n\n    return 0; // إنهاء البرنامج بنجاح\n}\nشرح الكود\n\nالتضمينات (Includes):\n\niostream: للتعامل مع الإدخال والإخراج القياسي (مثل std::cout و std::cin).\n\nfstream: للتعامل مع تدفقات الملفات (مثل std::ifstream لقراءة الملفات).\n\nstring: لاستخدام كائن std::string.\n\nsstream: لاستخدام std::stringstream لتسهيل تقسيم الأسطر إلى كلمات.\n\nالدالة الرئيسية main:\n\nتعريف المتغيرات:\n\nfileName: لتخزين اسم الملف الذي يدخله المستخدم.\n\nwordToSearch: لتخزين الكلمة التي يريد المستخدم عدها.\n\nwordCount: عداد لتتبع عدد مرات ظهور الكلمة.\n\nإدخال المستخدم: يطلب البرنامج من المستخدم إدخال اسم الملف والكلمة المراد البحث عنها.\n\nفتح الملف: يتم استخدام std::ifstream inputFile(fileName); لإنشاء كائن دفق ملف إدخال وفتح الملف المحدد.\n\nالتحقق من الملف: if (!inputFile.is_open()) يتحقق مما إذا كان الملف قد تم فتحه بنجاح. إذا لم يكن الأمر كذلك، فإنه يطبع رسالة خطأ وينهي البرنامج.\n\nقراءة الملف:\n\nwhile (std::getline(inputFile, line)) يقرأ الملف سطراً بسطر ويخزن كل سطر في المتغير line.\n\nداخل الحلقة، يتم استخدام std::stringstream ss(line); لإنشاء دفق سلسلة من السطر الحالي. هذا يسمح لنا بمعاملة السطر كنهر من الكلمات.\n\nwhile (ss >> word) تستخرج الكلمات واحدة تلو الأخرى من stringstream.\n\nif (word == wordToSearch) يقارن الكلمة الحالية بالكلمة الهدف، وإذا تطابقتا، يزيد العداد wordCount.\n\nإغلاق الملف: inputFile.close(); يغلق الملف بعد الانتهاء من القراءة.\n\nطباعة النتيجة: يتم عرض العدد الإجمالي لتكرار الكلمة على الشاشة.\n\nGoogle Search Suggestions\nDisplay of Search Suggestions is required when using Grounding with Google Search. Learn more\nC++ read file line by line and count word occurrences\nC++ count occurrences of a word in a file\n"]}]}
{"question_id": 72, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["def longest_common_subsequence(s1, s2):\n    m = len(s1)\n    n = len(s2)\n\n    # إنشاء جدول لتخزين أطوال LCS\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # ملء الجدول باستخدام البرمجة الديناميكية\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # إعادة بناء أطول تسلسل فرعي مشترك\n    index = dp[m][n]\n    lcs = [""] * (index + 1)\n    lcs[index] = ""\n\n    i = m\n    j = n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            lcs[index - 1] = s1[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return "".join(lcs)\n\n# مثال على الاستخدام:\n# s1 = \"ABCBDAB\"\n# s2 = \"BDCABA\"\n# print(longest_common_subsequence(s1, s2))  # الناتج: BCBA"]}]}
{"question_id": 73, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["بالتأكيد، إليك تعبير عادي (Regular Expression) بلغة بايثون للتحقق من صحة عناوين البريد الإلكتروني.\n\n\nimport re\n\ndef validate_email(email_address):\n    # التعبير العادي للتحقق من صحة عنوان البريد الإلكتروني\n    # هذا التعبير يدعم معظم تنسيقات عناوين البريد الإلكتروني الشائعة\n    # ولكنه قد لا يغطي جميع الحالات النادرة أو المعقدة.\n    regex = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n\n    if re.match(regex, email_address):\n        return True\n    else:\n        return False\n\n# أمثلة للاستخدام:\nemail1 = \"test@example.com\"\nemail2 = \"john.doe123@sub.domain.co.uk\"\nemail3 = \"invalid-email\"\nemail4 = \"another.email+tag@example.net\"\nemail5 = \"@missingusername.com\"\nemail6 = \"username@.com\"\nemail7 = \"username@domain\"\n\nprint(f\"'{email1}' is valid: {validate_email(email1)}\") # True\nprint(f\"'{email2}' is valid: {validate_email(email2)}\") # True\nprint(f\"'{email3}' is valid: {validate_email(email3)}\") # False\nprint(f\"'{email4}' is valid: {validate_email(email4)}\") # True\nprint(f\"'{email5}' is valid: {validate_email(email5)}\") # False\nprint(f\"'{email6}' is valid: {validate_email(email6)}\") # False\nprint(f\"'{email7}' is valid: {validate_email(email7)}\") # False\n\nشرح التعبير العادي r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\":\n\n^: يطابق بداية السلسلة.\n\n[a-zA-Z0-9._%+-]+: يطابق جزء اسم المستخدم (قبل @).\n\na-zA-Z0-9: يسمح بالأحرف الإنجليزية الكبيرة والصغيرة والأرقام.\n\n._%+-: يسمح بالنقاط، والشرطات السفلية، وعلامات النسبة المئوية، وعلامات الزائد، والشرطات.\n\n+: يعني وجود واحد أو أكثر من هذه الأحرف.\n\n@: يطابق رمز @ بالضبط.\n\n[a-zA-Z0-9.-]+: يطابق جزء اسم النطاق (بعد @ وقبل آخر نقطة).\n\na-zA-Z0-9: يسمح بالأحرف الإنجليزية الكبيرة والصغيرة والأرقام.\n\n.-: يسمح بالنقاط والشرطات.\n\n+: يعني وجود واحد أو أكثر من هذه الأحرف.\n\n\\.: يطابق النقطة بالضبط (يجب تهريب النقطة . لأنها حرف خاص في التعبيرات العادية).\n\n[a-zA-Z]{2,}: يطابق امتداد النطاق (مثل com, org, net, co.uk).\n\na-zA-Z: يسمح فقط بالأحرف الإنجليزية.\n\n{2,}: يعني وجود حرفين أو أكثر.\n\n$: يطابق نهاية السلسلة.\n\nملاحظات هامة:\n\nالتعقيد: التحقق من صحة البريد الإلكتروني بشكل كامل هو مهمة معقدة للغاية، وهذا التعبير العادي يغطي معظم الحالات الشائعة ولكنه قد لا يطابق جميع عناوين البريد الإلكتروني الصالحة وفقًا للمواصفات الرسمية (RFCs).\n\nالدقة: بعض التعبيرات العادية الأكثر تعقيدًا قد توفر دقة أعلى ولكنها قد تكون أصعب في الفهم والصيانة.\n\nالتحقق الفعلي: أفضل طريقة للتحقق من صحة عنوان بريد إلكتروني هي إرسال بريد إلكتروني تأكيدي إليه. التعبيرات العادية تتحقق فقط من التنسيق، وليس ما إذا كان العنوان موجودًا بالفعل أو نشطًا.\n\nإذا كان لديك أي أسئلة أخرى أو أردت تعديل التعبير العادي، فلا تتردد في السؤال!"]}]}
{"question_id": 74, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["برنامج بايثون لحساب العدد F_n باستخدام البرمجة الديناميكية:\n\n\ndef fibonacci_dynamic(n):\n    # تحقق من صحة المدخلات\n    if n < 0:\n        return \"العدد n يجب أن يكون عددًا صحيحًا غير سالب.\"\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        # إنشاء جدول (مصفوفة) لتخزين القيم المحسوبة مسبقًا\n        # حجم الجدول سيكون n+1 لأننا نحتاج لتخزين F_0 إلى F_n\n        dp = [0] * (n + 1)\n\n        # تهيئة القيم الأساسية\n        dp[0] = 0\n        dp[1] = 1\n\n        # ملء الجدول باستخدام العلاقات التكرارية\n        # F_i = F_{i-1} + F_{i-2}\n        for i in range(2, n + 1):\n            dp[i] = dp[i-1] + dp[i-2]\n\n        # العدد الفيبوناتشي n هو القيمة المخزنة في dp[n]\n        return dp[n]\n\n# أمثلة على الاستخدام:\nprint(f\"F_0 = {fibonacci_dynamic(0)}\")   # الناتج: 0\nprint(f\"F_1 = {fibonacci_dynamic(1)}\")   # الناتج: 1\nprint(f\"F_2 = {fibonacci_dynamic(2)}\")   # الناتج: 1\nprint(f\"F_6 = {fibonacci_dynamic(6)}\")   # الناتج: 8 (0, 1, 1, 2, 3, 5, 8)\nprint(f\"F_10 = {fibonacci_dynamic(10)}\") # الناتج: 55\nprint(f\"F_20 = {fibonacci_dynamic(20)}\") # الناتج: 6765\nprint(f\"F_30 = {fibonacci_dynamic(30)}\") # الناتج: 832040\nprint(f\"F_-5 = {fibonacci_dynamic(-5)}\") # الناتج: العدد n يجب أن يكون عددًا صحيحًا غير سالب.\n\nشرح البرنامج:\n\nدالة fibonacci_dynamic(n):\n\nتأخذ عددًا صحيحًا n كوسيط.\n\nمعالجة الحالات الأساسية (Base Cases):\n\nif n < 0:: تتأكد من أن n ليس سالبًا. أعداد فيبوناتشي معرفة للأعداد الصحيحة غير السالبة.\n\nelif n == 0:: العدد الفيبوناتشي الأول (F_0) هو 0.\n\nelif n == 1:: العدد الفيبوناتشي الثاني (F_1) هو 1.\n\nإنشاء جدول البرمجة الديناميكية (dp array):\n\ndp = [0] * (n + 1): يتم إنشاء قائمة (مصفوفة في لغات أخرى) تسمى dp (اختصار لـ \"dynamic programming\"). حجم هذه القائمة هو n + 1 لتخزين أعداد فيبوناتشي من F_0 إلى F_n. يتم تهيئتها جميعًا بالصفر مبدئيًا.\n\nتهيئة القيم الأولية في الجدول:\n\ndp[0] = 0: نضع القيمة 0 في الموقع 0، والتي تمثل F_0.\n\ndp[1] = 1: نضع القيمة 1 في الموقع 1، والتي تمثل F_1.\n\nملء الجدول تكراريًا:\n\nfor i in range(2, n + 1):: نبدأ حلقة من i = 2 (لأن F_0 و F_1 محسوبان بالفعل) حتى n.\n\ndp[i] = dp[i-1] + dp[i-2]: هذه هي العلاقة التكرارية الأساسية لأعداد فيبوناتشي. لحساب F_i، نجمع القيمتين السابقتين (F_{i-1} و F_{i-2}) المخزنتين بالفعل في الجدول. هذا هو جوهر البرمجة الديناميكية: حل المشكلة بتقسيمها إلى مشكلات فرعية أصغر وتخزين نتائج هذه المشكلات الفرعية لتجنب إعادة حسابها.\n\nإرجاع النتيجة:\n\nreturn dp[n]: بعد ملء الجدول بالكامل، ستكون القيمة المطلوبة F_n مخزنة في dp[n].\n\nلماذا هذه الطريقة فعالة (مقارنة بالطريقة التكرارية البسيطة):\n\nتجنب إعادة الحساب: الطريقة التكرارية البسيطة (التي تستخدم الاستدعاء الذاتي) تعيد حساب نفس أعداد فيبوناتشي مرارًا وتكرارًا. على سبيل المثال، لحساب F_5، تحتاج إلى F_4 و F_3. ولحساب F_4، تحتاج إلى F_3 و F_2. تلاحظ أن F_3 يتم حسابه مرتين. مع زيادة n، يزداد عدد مرات إعادة الحساب بشكل كبير، مما يؤدي إلى تعقيد زمني أسي (O(2^n)).\n\nالبرمجة الديناميكية (Dynamic Programming): من خلال تخزين النتائج في الجدول dp، يتم حساب كل عدد فيبوناتشي مرة واحدة فقط. عندما نحتاج إلى قيمة F_k، فإننا إما نجدها في الجدول (dp[k]) إذا كانت قد حسبت بالفعل، أو نحسبها مرة واحدة ونخزنها. هذا يقلل التعقيد الزمني إلى خطي (O(n))، مما يجعلها أكثر كفاءة بكثير للأعداد الكبيرة من n.\n\nمثال مرئي لكيفية عمل جدول dp لـ n=6:\n\n<br>\nF_0 = 0\nF_1 = 1\n\n\nDP Table (n+1 size): [0, 1, 0, 0, 0, 0, 0]\n\nLoop i = 2:\ndp[2] = dp[1] + dp[0] = 1 + 0 = 1\nDP Table: [0, 1, 1, 0, 0, 0, 0] (F_2 = 1)\n\nLoop i = 3:\ndp[3] = dp[2] + dp[1] = 1 + 1 = 2\nDP Table: [0, 1, 1, 2, 0, 0, 0] (F_3 = 2)\n\nLoop i = 4:\ndp[4] = dp[3] + dp[2] = 2 + 1 = 3\nDP Table: [0, 1, 1, 2, 3, 0, 0] (F_4 = 3)\n\nLoop i = 5:\ndp[5] = dp[4] + dp[3] = 3 + 2 = 5\nDP Table: [0, 1, 1, 2, 3, 5, 0] (F_5 = 5)\n\nLoop i = 6:\ndp[6] = dp[5] + dp[4] = 5 + 3 = 8\nDP Table: [0, 1, 1, 2, 3, 5, 8] (F_6 = 8)\n\nFinal Result: dp[6] = 8\n<br>"]}]}
{"question_id": 75, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["تُعد خوارزمية البحث الثنائي طريقة فعّالة للعثور على عنصر في مصفوفة مرتبة.\n\nإليك كيفية عملها خطوة بخطوة، مع مثال توضيحي:\n\n1. المفهوم الأساسي:\n\nتعتمد الخوارزمية على تقسيم المصفوفة إلى نصفين بشكل متكرر. في كل خطوة، نقارن العنصر الذي نبحث عنه بالعنصر الأوسط في الجزء الحالي من المصفوفة.\n\nإذا كان العنصر الأوسط هو العنصر الذي نبحث عنه، فقد وجدناه!\n\nإذا كان العنصر الذي نبحث عنه أصغر من العنصر الأوسط، فإننا نعلم أنه يجب أن يكون في النصف الأيسر من المصفوفة.\n\nإذا كان العنصر الذي نبحث عنه أكبر من العنصر الأوسط، فإننا نعلم أنه يجب أن يكون في النصف الأيمن من المصفوفة.\n\nنستمر في تكرار هذه العملية حتى نجد العنصر أو حتى يتبقى لدينا جزء فارغ من المصفوفة (مما يعني أن العنصر غير موجود).\n\n2. مثال عملي:\n\nلنفترض أن لدينا المصفوفة المرتبة التالية: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91] ونريد البحث عن الرقم 23.\n\nالخطوة 1:\n\nبداية = 0 (مؤشر أول عنصر)\n\nنهاية = 9 (مؤشر آخر عنصر)\n\nمنتصف = (0 + 9) // 2 = 4\n\nالمصفوفة[منتصف] = المصفوفة[4] = 16\n\n23 أكبر من 16، لذا ننتقل إلى النصف الأيمن.\n\nالخطوة 2:\n\nبداية = منتصف + 1 = 5\n\nنهاية = 9\n\nمنتصف = (5 + 9) // 2 = 7\n\nالمصفوفة[منتصف] = المصفوفة[7] = 56\n\n23 أصغر من 56، لذا ننتقل إلى النصف الأيسر.\n\nالخطوة 3:\n\nبداية = 5\n\nنهاية = منتصف - 1 = 6\n\nمنتصف = (5 + 6) // 2 = 5\n\nالمصفوفة[منتصف] = المصفوفة[5] = 23\n\nلقد وجدنا العنصر!\n\n3. الصورة التوضيحية:\n\nلفهم أفضل، إليك رسم توضيحي يوضح عملية البحث في كل خطوة:"]}]}
{"question_id": 76, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["تفضّل، هذه هي بنية بيانات قائمة الانتظار في بايثون باستخدام كومة:\n\n\nclass QueueFromStacks:\n    def __init__(self):\n        self.in_stack = []  # للعمليات push\n        self.out_stack = [] # للعمليات pop\n\n    def _transfer_elements(self):\n        \"""ينقل العناصر من in_stack إلى out_stack.\"""\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n\n    def enqueue(self, item):\n        \"""يضيف عنصرًا إلى نهاية قائمة الانتظار.\"""\n        self.in_stack.append(item)\n\n    def dequeue(self):\n        \"""يزيل العنصر من بداية قائمة الانتظار ويعيده.\"""\n        self._transfer_elements()\n        if not self.out_stack:\n            raise IndexError(\"لا يمكن إزالة عنصر من قائمة انتظار فارغة.\")\n        return self.out_stack.pop()\n\n    def peek(self):\n        \"""يعيد العنصر الموجود في بداية قائمة الانتظار دون إزالته.\"""\n        self._transfer_elements()\n        if not self.out_stack:\n            raise IndexError(\"قائمة الانتظار فارغة.\")\n        return self.out_stack[-1]\n\n    def is_empty(self):\n        \"""يتحقق مما إذا كانت قائمة الانتظار فارغة.\"""\n        return not self.in_stack and not self.out_stack\n\n    def size(self):\n        \"""يعيد عدد العناصر في قائمة الانتظار.\"""\n        return len(self.in_stack) + len(self.out_stack)\n\n# مثال على الاستخدام:\nq = QueueFromStacks()\nq.enqueue(1)\nq.enqueue(2)\nq.enqueue(3)\n\nprint(f\"قائمة الانتظار فارغة؟ {q.is_empty()}\") # False\nprint(f\"حجم قائمة الانتظار: {q.size()}\")       # 3\nprint(f\"العنصر في البداية (peek): {q.peek()}\")  # 1\n\nprint(f\"إزالة عنصر: {q.dequeue()}\") # 1\nprint(f\"إزالة عنصر: {q.dequeue()}\") # 2\n\nq.enqueue(4)\nprint(f\"حجم قائمة الانتظار بعد الإضافة: {q.size()}\") # 2\nprint(f\"العنصر في البداية (peek): {q.peek()}\")        # 3\nprint(f\"إزالة عنصر: {q.dequeue()}\")                 # 3\nprint(f\"إزالة عنصر: {q.dequeue()}\")                 # 4\nprint(f\"قائمة الانتظار فارغة؟ {q.is_empty()}\")     # True\n\ntry:\n    q.dequeue()\nexcept IndexError as e:\n    print(e) # لا يمكن إزالة عنصر من قائمة انتظار فارغة.\n\nشرح الفكرة:\n\nالفكرة الرئيسية هنا هي استخدام كومتين (في بايثون، نستخدم القوائم كمحاكاة للكومات) لمحاكاة سلوك قائمة الانتظار (FIFO - الأول يدخل، الأول يخرج).\n\nin_stack (كومة الإدخال):\n\nعندما تضيف عنصرًا (enqueue)، يتم دفعه ببساطة إلى in_stack. هذا يحاكي إضافة عناصر إلى نهاية قائمة الانتظار.\n\nout_stack (كومة الإخراج):\n\nعندما تريد إزالة عنصر (dequeue) أو النظر إلى العنصر الأول (peek)، فإنك تحتاج إلى الوصول إلى العنصر الأقدم الذي تم إضافته.\n\nإذا كانت out_stack فارغة، فهذا يعني أننا بحاجة إلى \"قلب\" ترتيب العناصر من in_stack. نقوم بذلك عن طريق نقل جميع العناصر من in_stack إلى out_stack. أثناء النقل، يتم قلب الترتيب بشكل طبيعي: العنصر الأقدم في in_stack سيصبح في الجزء العلوي من out_stack.\n\nبعد النقل (أو إذا كانت out_stack تحتوي بالفعل على عناصر)، يمكنك إزالة العنصر من out_stack أو النظر إليه.\n\nالعمليات الرئيسية:\n\nenqueue(self, item):\n\nبسيطة جدًا، تضيف العنصر مباشرة إلى in_stack. هذه عملية O(1) (وقت ثابت).\n\ndequeue(self):\n\nتستدعي _transfer_elements() لضمان وجود عناصر في out_stack إذا لزم الأمر.\n\nثم تزيل العنصر من out_stack.\n\nفي أسوأ الحالات (عندما تكون out_stack فارغة و in_stack مليئة)، تكون هذه العملية O(N) حيث N هو عدد العناصر في in_stack، ولكن متوسط التكلفة لكل عملية هو O(1) (وقت ثابت مُعدل)، لأن كل عنصر يتم دفعه وسحبه مرة واحدة فقط بين الكومتين على مدى دورة حياة قائمة الانتظار.\n\npeek(self):\n\nمشابهة لـ dequeue، تستخدم _transfer_elements() ثم تعيد العنصر العلوي من out_stack دون إزالته. أيضًا O(1) مُعدل.\n\nis_empty(self):\n\nتتحقق مما إذا كانت كلتا الكومتين فارغتين. O(1).\n\nsize(self):\n\nتجمع أحجام الكومتين. O(1).\n\nلماذا تعمل؟\n\nتخيل أنك تضع كتبًا في كومة (in_stack). الكتاب الأول الذي تضعه هو في الأسفل، والأخير هو في الأعلى.\nعندما تحتاج إلى إخراج الكتاب الأول (مثل قائمة الانتظار)، يمكنك أخذ جميع الكتب من الكومة الأولى ووضعها في كومة ثانية (out_stack). الآن، الكتاب الذي كان في الأسفل في الكومة الأولى هو في الأعلى في الكومة الثانية، ويمكنك إخراجه بسهولة.\n\nإليك رسم توضيحي للمفهوم:\n\n\nin_stack             out_stack\n        +---+                +---+\nenqueue(1)| 1 |                |   |\nenqueue(2)| 2 |                |   |\nenqueue(3)| 3 |                |   |\n        +---+                +---+\n        bottom                bottom\n\nعند استدعاء dequeue() لأول مرة:\n\ncode\nCode\ndownload\ncontent_copy\nexpand_less\n\nin_stack             out_stack\n        +---+                +---+\n        |   |                | 1 |  <-- peek/dequeue (أولًا)\n        |   |                | 2 |\n        |   |                | 3 |\n        +---+                +---+\n        empty                 bottom"]}]}
{"question_id": 77, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["إليك برنامج بلغة Python للعثور على العناصر المشتركة في مصفوفتين دون استخدام هياكل بيانات إضافية (مثل مجموعات أو قواميس). تعتمد هذه الطريقة على البحث الخطي لكل عنصر في المصفوفة الأولى داخل المصفوفة الثانية.\ndef find_common_elements(arr1, arr2):\n    \"""\n    تجد العناصر المشتركة بين مصفوفتين دون استخدام هياكل بيانات إضافية.\n\n    Args:\n        arr1 (list): المصفوفة الأولى.\n        arr2 (list): المصفوفة الثانية.\n\n    Returns:\n        list: قائمة بالعناصر المشتركة.\n    \"""\n    common_elements = []\n    \n    for item1 in arr1:\n        for item2 in arr2:\n            if item1 == item2:\n                # تحقق للتأكد من أننا لا نضيف نفس العنصر المكرر عدة مرات\n                if item1 not in common_elements:\n                    common_elements.append(item1)\n                break # بمجرد العثور على تطابق، انتقل إلى العنصر التالي في arr1\n                \n    return common_elements\n\n# أمثلة للاستخدام:\narray1 = [1, 2, 3, 4, 5]\narray2 = [4, 5, 6, 7, 8]\ncommon = find_common_elements(array1, array2)\nprint(f\"العناصر المشتركة بين {array1} و {array2} هي: {common}\")\n\narray3 = [10, 20, 30, 40]\narray4 = [30, 10, 50, 60]\ncommon2 = find_common_elements(array3, array4)\nprint(f\"العناصر المشتركة بين {array3} و {array4} هي: {common2}\")\n\narray5 = [1, 2, 2, 3, 4]\narray6 = [2, 4, 4, 5, 6]\ncommon3 = find_common_elements(array5, array6)\nprint(f\"العناصر المشتركة بين {array5} و {array6} هي: {common3}\")\n\narray7 = [\"apple\", \"banana\", \"orange\"]\narray8 = [\"banana\", \"grape\", \"apple\"]\ncommon4 = find_common_elements(array7, array8)\nprint(f\"العناصر المشتركة بين {array7} و {array8} هي: {common4}\")\n\nشرح البرنامج:\n\nالدالة find_common_elements(arr1, arr2):\n\nتأخذ مصفوفتين arr1 و arr2 كمدخلات.\n\nتُنشئ قائمة فارغة common_elements لتخزين العناصر المشتركة التي سيتم العثور عليها.\n\nالحلقة الخارجية for item1 in arr1::\n\nتكرر على كل عنصر (item1) في المصفوفة الأولى arr1.\n\nالحلقة الداخلية for item2 in arr2::\n\nلكل item1، تكرر هذه الحلقة على كل عنصر (item2) في المصفوفة الثانية arr2.\n\nالشرط if item1 == item2::\n\nإذا كان item1 من arr1 يطابق item2 من arr2، فهذا يعني أننا وجدنا عنصرًا مشتركًا.\n\nالشرط if item1 not in common_elements::\n\nهذا الشرط مهم. نظرًا لأننا لا نستخدم مجموعات (sets) التي تتعامل تلقائيًا مع العناصر الفريدة، يجب علينا التحقق يدويًا مما إذا كان item1 قد تم إضافته بالفعل إلى قائمة common_elements. هذا يضمن أن العناصر المكررة في المصفوفات الأصلية لا تظهر عدة مرات في قائمة النتائج.\n\ncommon_elements.append(item1):\n\nإذا لم يكن العنصر موجودًا بالفعل في common_elements، يتم إضافته.\n\nbreak:\n\nبمجرد العثور على تطابق لـ item1 معين في arr2، لا داعي لمواصلة البحث عن item1 نفسه في بقية arr2. يمكننا الانتقال إلى العنصر التالي في arr1. هذا يحسن الأداء قليلاً.\n\nreturn common_elements:\n\nبعد فحص جميع العناصر في arr1، تُرجع الدالة قائمة common_elements التي تحتوي على جميع العناصر المشتركة.\n\nاعتبارات الأداء:\n\nالتعقيد الزمني (Time Complexity): هذه الطريقة لها تعقيد زمني قدره O(m*n) في أسوأ الحالات، حيث m هو طول arr1 و n هو طول arr2. وذلك لأننا نمر على كل عنصر في المصفوفة الأولى ونقارنه بكل عنصر في المصفوفة الثانية. في كل تكرار، هناك أيضًا فحص item1 not in common_elements، والذي يمكن أن يستغرق O(k) حيث k هو طول common_elements.\n\nالتعقيد المكاني (Space Complexity): التعقيد المكاني هو O(min(m, n)) في أسوأ الحالات، وذلك لأن قائمة common_elements يمكن أن تحتوي على عدد العناصر المشتركة، والتي لا يمكن أن تتجاوز طول المصفوفة الأصغر. بما أنك طلبت عدم استخدام \"هياكل بيانات إضافية\" (أي شيء يتجاوز الضرورة لتخزين النتائج)، فهذا يعتبر مقبولاً.\n\nإذا كنت تبحث عن طريقة أكثر كفاءة، فإن استخدام هياكل بيانات إضافية مثل set (المجموعات) سيكون أسرع بكثير (بمتوسط O(m+n))، ولكنه يتعارض مع شرطك. هذه الطريقة تلتزم بعدم استخدام هياكل بيانات إضافية بخلاف قائمة النتائج."]}]}
{"question_id": 78, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["لحساب قيمة f(2)، نعوض x بالرقم 2 في الدالة f(x) = 5x^3 - 2x + 3.\n\nf(2) = 5(2)^3 - 2(2) + 3\nf(2) = 5(8) - 4 + 3\nf(2) = 40 - 4 + 3\nf(2) = 36 + 3\nf(2) = 39\n\nإذن، f(2) = 39."]}]}
{"question_id": 71, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["لحل المعادلة 3x + 10 = 5(x - 2) وإيجاد قيمة x، اتبع الخطوات التالية:\n\nوزع (انشر) الرقم 5 في الطرف الأيمن من المعادلة:\n3x + 10 = 5x - 10\n\nاجمع الحدود المتشابهة. انقل جميع الحدود التي تحتوي على x إلى أحد طرفي المعادلة وجميع الثوابت إلى الطرف الآخر.\nيمكننا طرح 3x من كلا الطرفين:\n10 = 5x - 3x - 10\n10 = 2x - 10\n\nأضف 10 إلى كلا الطرفين لنقل الثوابت:\n10 + 10 = 2x\n20 = 2x\n\nاقسم كلا الطرفين على 2 لحل قيمة x:\nx = 20 / 2\nx = 10\n\nإذن، قيمة x في المعادلة هي 10."]}]}
{"question_id": 80, "model_id": "gemini-2.5-pro", "choices": [{"index": 0, "turns": ["لحساب طول قطعة خطية، يمكنك استخدام صيغة المسافة. صيغة المسافة هي:\n\nd = √[(x₂ - x₁)² + (y₂ - y₁)²]\n\nحيث (x₁، y₁) و (x₂، y₂) هي إحداثيات نقاط النهاية.\n\nفي هذه الحالة، نقاط النهاية هي (2، -2) و (10، 4).\n\nلذلك،\nx₁ = 2\ny₁ = -2\nx₂ = 10\ny₂ = 4\n\nالآن، أدخل هذه القيم في صيغة المسافة:\n\nd = √[(10 - 2)² + (4 - (-2))²]\nd = √[(8)² + (6)²]\nd = √[64 + 36]\nd = √[100]\nd = 10\n\nإذًا، طول القطعة الخطية هو 10 وحدات.\n\nوإليك رسم توضيحي يوضح القطعة الخطية:"]}]}
