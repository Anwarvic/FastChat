{"question_id": 71, "answer_id": "resp_04b00d99a22e171b0068dbf893619481a38fd1d9bae0c81bfa", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["إليك برنامج C++ بسيط يقرأ ملفًا نصيًا سطرًا بسطر ويعد عدد مرات ظهور كلمة محددة كـ\"كلمة كاملة\" (مقسّمة بالفراغات). يعالج علامات الترقيم الإنجليزية الملتصقة بالكلمة في البداية أو النهاية.\n\nالملف: count_word.cpp\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nvoid trim_ascii_punct(string& s) {\n    const string punct = \" \\t\\r\\n.,;:!?\\\"'()[]{}<>/\\\\|`~@#$%^&*-_=+\";\n    size_t start = 0;\n    while (start < s.size() && punct.find(s[start]) != string::npos) ++start;\n    size_t end = s.size();\n    while (end > start && punct.find(s[end - 1]) != string::npos) --end;\n    s = s.substr(start, end - start);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string filename, target;\n    cout << \"أدخل اسم الملف: \";\n    getline(cin, filename);\n    cout << \"أدخل الكلمة المطلوب عدّها: \";\n    getline(cin, target);\n\n    ifstream in(filename);\n    if (!in) {\n        cerr << \"تعذّر فتح الملف: \" << filename << \"\\n\";\n        return 1;\n    }\n\n    // إزالة ترقيم محتمل حول الكلمة الهدف (اختياري)\n    trim_ascii_punct(target);\n\n    size_t count = 0;\n    string line;\n    while (getline(in, line)) {\n        istringstream iss(line);\n        string token;\n        while (iss >> token) {\n            trim_ascii_punct(token);\n            if (token == target) {\n                ++count;\n            }\n        }\n    }\n\n    cout << \"عدد مرات ظهور الكلمة \\\"\" << target << \"\\\": \" << count << \"\\n\";\n    return 0;\n}\n\nملاحظات:\n- البرنامج يعدّ المطابقات كـ\"كلمة كاملة\" مفصولة بفراغات، مع تجاهل علامات الترقيم الإنجليزية المحيطة مثل . , ! ? وغيرها.\n- إن أردت عدًّا غير حساس لحالة الأحرف (مفيد للإنجليزية)، يمكن تحويل كل من token وtarget إلى أحرف صغيرة قبل المقارنة.\n- بالنسبة للغات غير الإنجليزية (مثل العربية)، لا حاجة عادةً لتحويل حالة الأحرف.\n\nطريقة الترجمة والتشغيل:\n- ترجمة: g++ -std=c++17 -O2 count_word.cpp -o count_word\n- تشغيل: \n  - عند التشغيل سيطلب منك اسم الملف ثم الكلمة:\n    - مثال الإدخال:\n      - أدخل اسم الملف: data.txt\n      - أدخل الكلمة المطلوب عدّها: كلمة\n\nهل تفضّل أن تكون الكلمة والحساسية لحالة الأحرف وخيارات أخرى عبر وسيطات سطر الأوامر؟ يمكنني تزويدك بنسخة تدعم ذلك."]}], "tstamp": 1759246520.5022776}
{"question_id": 72, "answer_id": "resp_047efc9da2cbcaa70068dbf8b8aa84819dad4d7ea623c91a19", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["def longest_common_subsequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if s1[i] == s2[j]:\n                dp[i][j] = 1 + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = dp[i + 1][j] if dp[i + 1][j] >= dp[i][j + 1] else dp[i][j + 1]\n    i = j = 0\n    res = []\n    while i < m and j < n:\n        if s1[i] == s2[j]:\n            res.append(s1[i])\n            i += 1\n            j += 1\n        elif dp[i + 1][j] >= dp[i][j + 1]:\n            i += 1\n        else:\n            j += 1\n    return ''.join(res)"]}], "tstamp": 1759246540.4092727}
{"question_id": 73, "answer_id": "resp_0272646aa96f43fe0068dbf8cc8848819db042f84e782f8a5f", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["إليك تعبيرًا عاديًا عمليًا في بايثون للتحقق من صحة عناوين البريد الإلكتروني الشائعة (ASCII)، مع مراعاة طول العنوان، منع النقاط المزدوجة أو في بداية/نهاية الجزء المحلي، والتحقق من أسماء النطاقات:\n\nimport re\n\nEMAIL_REGEX = re.compile(\n    r'^(?=.{1,254}$)(?=.{1,64}@)'\n    r'(?!\\.)(?!.*\\.\\.)(?!.*\\.$)'\n    r'[A-Za-z0-9!#$%&\\'*+/=?^_`{|}~-]+(?:\\.[A-Za-z0-9!#$%&\\'*+/=?^_`{|}~-]+)*'\n    r'@'\n    r'(?:(?!-)[A-Za-z0-9-]{1,63}(?<!-)\\.)+(?!-)[A-Za-z0-9-]{2,63}(?<!-)$',\n    re.IGNORECASE\n)\n\ndef is_valid_email(email: str) -> bool:\n    return EMAIL_REGEX.fullmatch(email) is not None\n\n# أمثلة\ntests = [\n    \"user@example.com\",\n    \"first.last+tag@sub.domain.co\",\n    \"a-very_long-local-part@xn--exmple-cua.com\",\n    \".starts.with.dot@example.com\",\n    \"double..dot@example.com\",\n    \"ends.with.dot.@example.com\",\n    \"no-tld@localhost\",\n]\n\nfor t in tests:\n    print(t, \"=>\", is_valid_email(t))\n\nملاحظات سريعة:\n- هذا النمط يغطي الحالات الشائعة، ويشترط وجود نقطة في النطاق العام (TLD).\n- لا يدعم عناوين IP على هيئة [192.0.2.1] أو الجزء المحلي المُقتبس \"quoted\".\n- للدعم الكامل بما في ذلك العناوين الدولية (Unicode) والتحقق من وجود النطاق فعليًا، يفضَّل استخدام مكتبة email-validator."]}], "tstamp": 1759246582.8946476}
{"question_id": 74, "answer_id": "resp_0659646b10c702050068dbf8f7047c81a2aa872dc3b6e9c28b", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["إليك برنامجًا بسيطًا في بايثون يستخدم البرمجة الديناميكية (نهج تصاعدي مع تحسين الذاكرة) لحساب العدد الفيبوناتشي n:\n\ndef fib_dp(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n يجب أن يكون عددًا صحيحًا غير سالب\")\n    if n < 2:\n        return n\n    a, b = 0, 1  # يمثّلان F(0) و F(1)\n    for _ in range(2, n + 1):\n        a, b = b, a + b  # تتبع قيمتين فقط (ذاكرة O(1))\n    return b\n\n# مثال استخدام:\nif __name__ == \"__main__\":\n    # أدخل قيمة n واطبع F(n)\n    n = int(input().strip())\n    print(fib_dp(n))\n\nملاحظات:\n- التعقيد الزمني: O(n)\n- التعقيد المكاني: O(1)\n- يدعم n = 0 و n = 1 مباشرة، ويرفع خطأ للقيم السالبة."]}], "tstamp": 1759246604.867034}
{"question_id": 75, "answer_id": "resp_0e2bca1c5711b6e00068dbf90d0424819eac446288b08f0e33", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["إليك تنفيذًا بسيطًا للبحث الثنائي بلغة Python للعثور على عنصر في مصفوفة (قائمة) مرتبة تصاعديًا. تعيد الدالة فهرس العنصر إذا وُجد، أو -1 إذا لم يوجد.\n\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# مثال استخدام:\narr = [1, 3, 4, 6, 8, 10]\nprint(binary_search(arr, 6))  # 3\nprint(binary_search(arr, 7))  # -1\n\nملاحظات سريعة:\n- يجب أن تكون المصفوفة مرتبة تصاعديًا. إن كانت تنازليًا فاعكس المقارنة.\n- التعقيد الزمني: O(log n)، والتعقيد المكاني: O(1).\n- في حال وجود مكررات، تُرجع أي ظهور. إذا أردت أول ظهور، يمكن تعديل الشرط للحركة نحو اليسار عند التساوي."]}], "tstamp": 1759246617.0227542}
{"question_id": 76, "answer_id": "resp_0176d681be9f69d10068dbf919268c8197b516a1f8a7323fe0", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["إليك تنفيذ قائمة انتظار (Queue) باستخدام مكدسين (Stacks) في بايثون. الفكرة: نستخدم مكدساً للإدخال وآخر للإخراج، وننقل العناصر من الإدخال إلى الإخراج عند الحاجة فقط للحصول على تعقيد زمني أمثل amortized O(1).\n\nclass TwoStackQueue:\n    \"\"\"\n    قائمة انتظار مبنية على مكدسين.\n    - enqueue(x): إضافة عنصر إلى نهاية الطابور.\n    - dequeue(): إزالة وإرجاع أول عنصر.\n    - peek(): إرجاع أول عنصر دون إزالته.\n    - is_empty(): هل الطابور فارغ؟\n    - len(q) أو __len__: عدد العناصر.\n    \"\"\"\n    def __init__(self, iterable=None):\n        self._in = []   # مكدس الإدخال\n        self._out = []  # مكدس الإخراج\n        if iterable is not None:\n            for x in iterable:\n                self.enqueue(x)\n\n    def enqueue(self, x):\n        self._in.append(x)\n\n    def _shift(self):\n        # نقل العناصر من in إلى out عند الحاجة فقط\n        if not self._out:\n            while self._in:\n                self._out.append(self._in.pop())\n\n    def dequeue(self):\n        self._shift()\n        if not self._out:\n            raise IndexError(\"dequeue from empty queue\")\n        return self._out.pop()\n\n    def peek(self):\n        self._shift()\n        if not self._out:\n            raise IndexError(\"peek from empty queue\")\n        return self._out[-1]\n\n    def is_empty(self):\n        return not (self._in or self._out)\n\n    def __len__(self):\n        return len(self._in) + len(self._out)\n\n    def clear(self):\n        self._in.clear()\n        self._out.clear()\n\n    def __bool__(self):\n        return not self.is_empty()\n\n    def __repr__(self):\n        return f\"TwoStackQueue(in={self._in!r}, out={self._out!r})\"\n\n\n# مثال استخدام\nif __name__ == \"__main__\":\n    q = TwoStackQueue([1, 2, 3])\n    q.enqueue(4)           # الطابور الآن: 1,2,3,4\n    print(q.peek())        # 1\n    print(q.dequeue())     # 1\n    print(q.dequeue())     # 2\n    q.enqueue(5)           # الطابور: 3,4,5\n    print(len(q))          # 3\n    while not q.is_empty():\n        print(q.dequeue()) # يطبع: 3 ثم 4 ثم 5\n\n- التعقيد الزمني:\n  - enqueue: زمن ثابت O(1)\n  - dequeue/peek: amortized O(1)؛ وأحياناً O(n) عند التحويل، لكن متوسط العملية يظل O(1)."]}], "tstamp": 1759246650.1587763}
{"question_id": 77, "answer_id": "resp_00cf4d84725866d80068dbf93a6528819cb04db88f8c45faa1", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["الفكرة المختصرة:\n- رتب المصفوفتين في مكانهما (in-place).\n- استخدم مؤشرين للتقدّم خلالهما والعثور على العناصر المشتركة.\n- لا نستخدم أي هياكل بيانات إضافية (لا مجموعات/مصفوفات مساعدة). التعقيد: O(n log n + m log m) زمنًا، وO(1) مساحة إضافية.\n\nكود C++ (يطبع العناصر المشتركة بدون تكرار):\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid printCommonUnique(vector<int>& a, vector<int>& b) {\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    size_t i = 0, j = 0;\n    bool first = true;\n    int lastPrinted = 0; // غير مستخدم فعليًا لأننا نتجاوز التكرارات\n\n    while (i < a.size() && j < b.size()) {\n        if (a[i] == b[j]) {\n            int val = a[i];\n            // اطبع مرة واحدة وتجاوز كل التكرارات في المصفوفتين\n            cout << val << \" \";\n            while (i < a.size() && a[i] == val) ++i;\n            while (j < b.size() && b[j] == val) ++j;\n        } else if (a[i] < b[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n    cout << \"\\n\";\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    if (!(cin >> n)) return 0;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) cin >> a[i];\n\n    cin >> m;\n    vector<int> b(m);\n    for (int i = 0; i < m; ++i) cin >> b[i];\n\n    printCommonUnique(a, b); // يطبع العناصر المشتركة دون تكرار\n    return 0;\n}\n\nملاحظات:\n- إذا أردت احتساب التكرارات (أي عنصر مشترك يظهر بعدد مرات التقاطع)، استبدل الدالة بالآتي:\nvoid printCommonWithCounts(vector<int>& a, vector<int>& b) {\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    size_t i = 0, j = 0;\n    while (i < a.size() && j < b.size()) {\n        if (a[i] == b[j]) {\n            cout << a[i] << \" \";\n            ++i; ++j;\n        } else if (a[i] < b[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n    cout << \"\\n\";\n}\n\n- إذا كانت المصفوفتان مرتبتين مسبقًا، احذف سطري sort لتصبح الدالة O(n + m).\n- إذا كان ممنوعًا تعديل المصفوفتين إطلاقًا، فلا يتبقى سوى الخوارزمية البسيطة O(n*m) بالتجربة لكل زوج عناصر (أبطأ، لكنها بلا هياكل إضافية)."]}], "tstamp": 1759246689.758372}
{"question_id": 78, "answer_id": "resp_09833ad2098fda0f0068dbf962abf481928fcfc2c34dcefb2c", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["f(2) = 5(2)^3 - 2(2) + 3 = 5×8 - 4 + 3 = 40 - 4 + 3 = 39."]}], "tstamp": 1759246694.0916367}
{"question_id": 79, "answer_id": "resp_0a3233d25d8bbc930068dbf9663f8481969a74eb2cb2963e66", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["لحل المعادلة 3x + 10 = 5(x − 2):\n\n- نفك القوس: 5(x − 2) = 5x − 10\n- تصبح: 3x + 10 = 5x − 10\n- ننقل الحدود: 10 + 10 = 5x − 3x ⇒ 20 = 2x\n- إذن: x = 10"]}], "tstamp": 1759246700.8008142}
{"question_id": 80, "answer_id": "resp_0de44c8ebb0bd0090068dbf96cf01881a0943efb09538376eb", "model_id": "gpt-5-2025-08-07", "choices": [{"index": 0, "turns": ["الطول = √[(10−2)² + (4−(−2))²] = √(8² + 6²) = √100 = 10."]}], "tstamp": 1759246704.760357}
