{"question_id":71,"category":"vicuna_ar","sub-category":"coding","turns":["اكتب برنامج C++ يقرأ ملف نصي سطرًا بسطر ويعد عدد المرات التي تظهر فيها كلمة معينة في الملف."],"answer":"بالتأكيد، إليك برنامج C++ كامل يقوم بما طلبته، مع شرح مفصل للكود وخطوات تشغيله.\n\n**الكود (count_words.cpp):**\n```cpp\n#include <iostream>   \/\/ للتعامل مع الإدخال والإخراج القياسي (cin, cout)\n#include <fstream>    \/\/ للتعامل مع الملفات (قراءة وكتابة)\n#include <string>     \/\/ للتعامل مع السلاسل النصية (string)\n#include <sstream>    \/\/ لتقسيم السطر إلى كلمات بسهولة (stringstream)\n\nint main() {\n    \/\/ تعريف المتغيرات التي سنستخدمها\n    std::string filename;      \/\/ لتخزين اسم الملف\n    std::string wordToFind;    \/\/ لتخزين الكلمة المراد البحث عنها\n    std::string line;          \/\/ لتخزين السطر الذي تتم قراءته حاليًا\n    std::string word;          \/\/ لتخزين الكلمة الحالية من السطر\n    int count = 0;             \/\/ عداد لتخزين عدد مرات ظهور الكلمة\n\n    \/\/ طلب اسم الملف من المستخدم\n    std::cout << \"ادخل اسم الملف (e.g., data.txt): \";\n    std::cin >> filename;\n\n    \/\/ طلب الكلمة المراد البحث عنها من المستخدم\n    std::cout << \"ادخل الكلمة للبحث عنها: \";\n    std::cin >> wordToFind;\n\n    \/\/ إنشاء كائن من نوع ifstream وفتح الملف المحدد\n    std::ifstream inputFile(filename);\n\n    \/\/ التحقق مما إذا كان الملف قد تم فتحه بنجاح\n    if (!inputFile.is_open()) {\n        \/\/ إذا فشل فتح الملف، اطبع رسالة خطأ وقم بإنهاء البرنامج\n        std::cerr << \"خطأ: لا يمكن فتح الملف '\" << filename << \"'\" << std::endl;\n        return 1; \/\/ الخروج من البرنامج مع رمز خطأ\n    }\n\n    \/\/ حلقة while لقراءة الملف سطراً بسطر حتى نهاية الملف\n    while (std::getline(inputFile, line)) {\n        \/\/ إنشاء كائن stringstream من السطر الحالي لتسهيل استخلاص الكلمات\n        std::stringstream ss(line);\n\n        \/\/ حلقة while داخلية لاستخلاص كل كلمة من السطر\n        while (ss >> word) {\n            \/\/ ملاحظة: هذه المقارنة حساسة لحالة الأحرف (case-sensitive)\n            \/\/ للتغلب على هذه المشكلة، يمكنك تحويل الكلمتين (word و wordToFind)\n            \/\/ إلى حالة أحرف موحدة (صغيرة أو كبيرة) قبل المقارنة.\n            if (word == wordToFind) {\n                count++; \/\/ إذا تطابقت، قم بزيادة العداد\n            }\n        }\n    }\n\n    \/\/ إغلاق الملف بعد الانتهاء من القراءة\n    inputFile.close();\n\n    \/\/ طباعة النتيجة النهائية للمستخدم\n    std::cout << \"\\nالنتيجة:\" << std::endl;\n    std::cout << \"تم العثور على الكلمة '\" << wordToFind << \"' عدد \" << count << \" مرة.\" << std::endl;\n\n    return 0; \/\/ الخروج من البرنامج بنجاح\n}\n```\n\n**شرح الكود:**\n1.  **`#include`**: يتم تضمين المكتبات اللازمة. `iostream` للإدخال والإخراج، `fstream` للتعامل مع الملفات، `string` للسلاسل النصية، و `sstream` لمعالجة السلاسل النصية كـ \"تيار\" من البيانات مما يسهل تقسيمها.\n2.  **`main()`**: الدالة الرئيسية للبرنامج.\n3.  **تعريف المتغيرات**: نعرّف متغيرات لتخزين اسم الملف، الكلمة المراد البحث عنها، والعداد.\n4.  **إدخال المستخدم**: يطلب البرنامج من المستخدم إدخال اسم الملف والكلمة.\n5.  **فتح الملف**: `std::ifstream inputFile(filename);` يحاول فتح الملف المحدد للقراءة فقط.\n6.  **التحقق من الملف**: `if (!inputFile.is_open())` يتأكد من أن الملف تم فتحه بنجاح. إذا لم يحدث ذلك، يطبع رسالة خطأ ويخرج.\n7.  **قراءة الملف**: الحلقة `while (std::getline(inputFile, line))` تقرأ الملف سطراً واحداً في كل مرة وتخزنه في المتغير `line`.\n8.  **تقسيم السطر**: داخل الحلقة، يتم استخدام `std::stringstream ss(line);` لتحويل السطر إلى تيار من الكلمات. بعد ذلك، الحلقة `while (ss >> word)` تستخرج كل كلمة على حدة من هذا التيار.\n9.  **المقارنة والعد**: `if (word == wordToFind)` يقارن الكلمة الحالية بالكلمة المطلوبة. إذا تطابقتا، يزداد العداد `count`.\n10. **إغلاق الملف**: بعد انتهاء الحلقة الرئيسية، يتم إغلاق الملف باستخدام `inputFile.close()`.\n11. **طباعة النتيجة**: يعرض البرنامج النتيجة النهائية للمستخدم.\n\n**كيفية التشغيل:**\n1.  **أنشئ ملفًا نصيًا**: قم بإنشاء ملف نصي بنفس المجلد الذي ستحفظ فيه الكود. لنسمه `data.txt` ونضع فيه المحتوى التالي:\n    ```text\n    hello world this is a test\n    hello again for another test\n    this test is simple\n    ```\n2.  **حفظ الكود**: احفظ الكود أعلاه في ملف باسم `count_words.cpp`.\n3.  **التجميع (Compile)**: افتح الطرفية (Terminal أو Command Prompt) وانتقل إلى المجلد الذي حفظت فيه الملفين، ثم نفذ الأمر التالي (تحتاج إلى مترجم C++ مثل g++):\n    ```bash\n    g++ count_words.cpp -o count_words\n    ```\n4.  **التشغيل (Execute)**: قم بتشغيل البرنامج الناتج:\n    ```bash\n    .\/count_words\n    ```\n\n**مثال على المخرجات عند التشغيل:**\n```\nادخل اسم الملف (e.g., data.txt): data.txt\nادخل الكلمة للبحث عنها: test\n\nالنتيجة:\nتم العثور على الكلمة 'test' عدد 3 مرة.\n```"}
{"question_id":72,"category":"vicuna_ar","sub-category":"coding","turns":["استخدم البرمجة الديناميكية لتنفيذ دالة بايثون للعثور على أطول تسلسل فرعي مشترك بين سلسلتين مدخلتين. يرجى تقديم محتوى الترجمة فقط وعدم تقديم أي معلومات إضافية."],"answer":"بالتأكيد. إليك دالة بايثون تستخدم البرمجة الديناميكية للعثور على أطول تسلسل فرعي مشترك (Longest Common Subsequence - LCS) بين سلسلتين.\n\n### خطوات الخوارزمية:\n\n1.  **إنشاء جدول (مصفوفة)**: يتم إنشاء جدول ثنائي الأبعاد `dp` بأبعاد `(m+1) x (n+1)`، حيث `m` و `n` هما أطوال السلسلتين. الخلية `dp[i][j]` ستحتوي على طول الـ LCS بين أول `i` حرف من السلسلة الأولى وأول `j` حرف من السلسلة الثانية.\n\n2.  **ملء الجدول**: يتم المرور على الجدول لملء القيم:\n    *   إذا كان الحرفان `s1[i-1]` و `s2[j-1]` متطابقين، فإن طول الـ LCS يزداد بمقدار واحد عن طوله للسلاسل الأقصر: `dp[i][j] = 1 + dp[i-1][j-1]`.\n    *   إذا كانا مختلفين، نأخذ القيمة الأكبر بين الحالتين: (LCS للسلسلة الأولى كاملة مع السلسلة الثانية منقوصة حرفًا) أو (LCS للسلسلة الأولى منقوصة حرفًا مع السلسلة الثانية كاملة). أي: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.\n\n3.  **إعادة بناء التسلسل**: بعد ملء الجدول، تكون القيمة في `dp[m][n]` هي *طول* الـ LCS. للعثور على التسلسل الفعلي، نبدأ من هذه الخلية الأخيرة ونتحرك بشكل عكسي عبر الجدول لتجميع الأحرف المشتركة.\n\n### كود بايثون\n\n```python\ndef lcs(s1, s2):\n    # الحصول على أطوال السلسلتين\n    m = len(s1)\n    n = len(s2)\n\n    # إنشاء جدول البرمجة الديناميكية (dp) بحجم (m+1) x (n+1)\n    # سيحتوي dp[i][j] على طول LCS لـ s1[0..i-1] و s2[0..j-1]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # بناء الجدول dp من الأسفل إلى الأعلى\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # إذا تطابق الحرفان الأخيران\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            # إذا لم يتطابقا، نأخذ القيمة القصوى من الخلية العلوية أو اليسرى\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # الآن، نقوم بتتبع الجدول من الخلية الأخيرة (dp[m][n]) لإعادة بناء سلسلة LCS\n    lcs_chars = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        # إذا كان الحرف الحالي في s1 و s2 متطابقًا، فهو جزء من LCS\n        if s1[i - 1] == s2[j - 1]:\n            lcs_chars.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        # إذا لم يتطابقا، نتحرك في اتجاه القيمة الأكبر في الجدول\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # نعكس القائمة ونضمها للحصول على LCS النهائي لأننا بنيناها من الخلف\n    return \"\".join(reversed(lcs_chars))\n\n# مثال على الاستخدام\nstr1 = \"AGGTAB\"\nstr2 = \"GXTXAYB\"\nprint(f\"السلسلة الأولى: {str1}\")\nprint(f\"السلسلة الثانية: {str2}\")\nresult = lcs(str1, str2)\nprint(f\"أطول تسلسل فرعي مشترك هو: {result}\")\n\n# --- مثال آخر ---\nstr3 = \"ABCDGH\"\nstr4 = \"AEDFHR\"\nprint(f\"\\nالسلسلة الأولى: {str3}\")\nprint(f\"السلسلة الثانية: {str4}\")\nresult2 = lcs(str3, str4)\nprint(f\"أطول تسلسل فرعي مشترك هو: {result2}\")\n```\n\n### الإخراج المتوقع للمثال:\n\n```\nالسلسلة الأولى: AGGTAB\nالسلسلة الثانية: GXTXAYB\nأطول تسلسل فرعي مشترك هو: GTAB\n\nالسلسلة الأولى: ABCDGH\nالسلسلة الثانية: AEDFHR\nأطول تسلسل فرعي مشترك هو: ADH\n```"}
{"question_id":73,"category":"vicuna_ar","sub-category":"coding","turns":["قم بتنفيذ تعبير عادي بلغة بايثون للتحقق من صحة عناوين البريد الإلكتروني."],"answer":"بالتأكيد، يمكنك استخدام وحدة `re` في بايثون للتحقق من صحة عناوين البريد الإلكتروني باستخدام التعابير العادية (Regular Expressions). إليك الخطوات الكاملة مع شرح للكود:\n\n### الخطوة 1: استيراد وحدة `re`\n\nأولاً، تحتاج إلى استيراد الوحدة المدمجة `re` التي توفر عمليات مطابقة التعابير العادية.\n\n```python\nimport re\n```\n\n### الخطوة 2: تحديد نمط التعبير العادي (Regex)\n\nسنقوم بإنشاء نمط (pattern) يمثل البنية القياسية للبريد الإلكتروني. النمط الشائع والموثوق لتغطية معظم الحالات هو:\n\n```\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n```\n\n**شرح تفصيلي للنمط:**\n\n*   `^`: يمثل بداية السلسلة النصية (بداية الإيميل).\n*   `[a-zA-Z0-9._%+-]+`: هذا الجزء يطابق \"اسم المستخدم\" في البريد الإلكتروني. ويعني:\n    *   `[...]`: تطابق أي حرف واحد موجود داخل الأقواس.\n    *   `a-zA-Z`: أي حرف أبجدي صغير أو كبير.\n    *   `0-9`: أي رقم.\n    *   `._%+-`: الحروف الخاصة المسموح بها (نقطة، شرطة سفلية، نسبة مئوية، زائد، شرطة).\n    *   `+`: تعني أن النمط السابق يجب أن يظهر مرة واحدة على الأقل.\n*   `@`: يطابق حرف `@` حرفيًا.\n*   `[a-zA-Z0-9.-]+`: هذا الجزء يطابق \"اسم النطاق\" (domain name). يسمح بالحروف والأرقام والنقاط والشرطات.\n*   `\\.`: يطابق النقطة `.` حرفيًا التي تفصل بين اسم النطاق والنطاق الأعلى (TLD). الشرطة المائلة للخلف `\\` ضرورية لأن النقطة لها معنى خاص في التعابير العادية (تطابق أي حرف).\n*   `[a-zA-Z]{2,}`: يطابق \"النطاق الأعلى\" (Top-Level Domain) مثل .com, .net, .org. ويعني:\n    *   `[a-zA-Z]`: يجب أن يكون حرفًا أبجديًا.\n    *   `{2,}`: يجب أن يتكون من حرفين على الأقل.\n*   `$`: يمثل نهاية السلسلة النصية (نهاية الإيميل).\n\n### الخطوة 3: كتابة دالة للتحقق من الصحة\n\nمن الأفضل وضع منطق التحقق داخل دالة لإعادة استخدامها بسهولة. ستأخذ هذه الدالة البريد الإلكتروني كمدخل وتعيد `True` إذا كان صالحًا و `False` إذا لم يكن كذلك.\n\nسوف نستخدم دالة `re.fullmatch()` التي تتأكد من أن النمط يطابق السلسلة النصية *بأكملها* من البداية إلى النهاية.\n\n### الخطوة 4: الكود الكامل والمثال\n\nإليك الكود الكامل الذي يجمع كل الخطوات مع أمثلة للتوضيح.\n\n```python\nimport re\n\ndef is_valid_email(email):\n    \"\"\"الدالة تتحقق من صحة البريد الإلكتروني باستخدام تعبير عادي.\"\"\"\n    # نمط التعبير العادي للتحقق من البريد الإلكتروني\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    # استخدام re.fullmatch() للتأكد من تطابق السلسلة بأكملها مع النمط\n    if re.fullmatch(pattern, email):\n        return True\n    else:\n        return False\n\n# --- أمثلة للتجربة ---\n\n# عناوين بريد إلكتروني صالحة\nvalid_emails = [\n    \"example@example.com\",\n    \"user.name@domain.co.uk\",\n    \"user-name123@my-domain.org\",\n    \"user+alias@gmail.com\"\n]\n\n# عناوين بريد إلكتروني غير صالحة\ninvalid_emails = [\n    \"example.com\",          # بدون @\n    \"user@.com\",            # نطاق غير صالح\n    \"@domain.com\",          # بدون اسم مستخدم\n    \"user@domain\",          # بدون نطاق المستوى الأعلى (TLD)\n    \"user@domain.c\",        # TLD قصير جدًا\n    \"user name@domain.com\"  # يحتوي على مسافة\n]\n\nprint(\"--- التحقق من العناوين الصالحة ---\")\nfor email in valid_emails:\n    if is_valid_email(email):\n        print(f'\"{email}\" هو بريد إلكتروني صالح.')\n    else:\n        print(f'\"{email}\" هو بريد إلكتروني غير صالح.')\n\nprint(\"\\n--- التحقق من العناوين غير الصالحة ---\")\nfor email in invalid_emails:\n    if is_valid_email(email):\n        print(f'\"{email}\" هو بريد إلكتروني صالح.')\n    else:\n        print(f'\"{email}\" هو بريد إلكتروني غير صالح.')\n\n```\n\n### مخرجات الكود:\n\n```\n--- التحقق من العناوين الصالحة ---\n\"example@example.com\" هو بريد إلكتروني صالح.\n\"user.name@domain.co.uk\" هو بريد إلكتروني صالح.\n\"user-name123@my-domain.org\" هو بريد إلكتروني صالح.\n\"user+alias@gmail.com\" هو بريد إلكتروني صالح.\n\n--- التحقق من العناوين غير الصالحة ---\n\"example.com\" هو بريد إلكتروني غير صالح.\n\"user@.com\" هو بريد إلكتروني غير صالح.\n\"@domain.com\" هو بريد إلكتروني غير صالح.\n\"user@domain\" هو بريد إلكتروني غير صالح.\n\"user@domain.c\" هو بريد إلكتروني غير صالح.\n\"user name@domain.com\" هو بريد إلكتروني غير صالح.\n```\n\nهذا الحل يوفر طريقة قوية وفعالة للتحقق من صحة معظم صيغ البريد الإلكتروني الشائعة في تطبيقات بايثون."}
{"question_id":74,"category":"vicuna_ar","sub-category":"coding","turns":["اكتب برنامجًا يستخدم البرمجة الديناميكية للعثور على العدد الفيبوناتشي n."],"answer":"بالتأكيد. إليك شرح كامل لبرنامج حساب العدد الفيبوناتشي n باستخدام البرمجة الديناميكية، مع شرح للطرق المختلفة وتقديم الكود البرمجي بلغة بايثون.\n\n### مقدمة عن متتالية فيبوناتشي\n\nمتتالية فيبوناتشي هي سلسلة من الأرقام حيث كل رقم هو مجموع الرقمين السابقين له. تبدأ المتتالية عادةً بالرقمين 0 و 1.\n\n- `F(0) = 0`\n- `F(1) = 1`\n- `F(n) = F(n-1) + F(n-2)`، لـ `n > 1`\n\nعلى سبيل المثال، أول عشرة أرقام في المتتالية هي: `0, 1, 1, 2, 3, 5, 8, 13, 21, 34`.\n\n### المشكلة في الحل العودي (Recursive)\n\nالحل العودي المباشر يقوم بحسابات متكررة بشكل كبير. على سبيل المثال، لحساب `fib(5)`، سيتم حساب `fib(3)` مرتين و `fib(2)` ثلاث مرات. هذا يؤدي إلى تعقيد زمني أُسّي (Exponential Time Complexity)، وهو غير فعال على الإطلاق للأعداد الكبيرة.\n\n### الحل باستخدام البرمجة الديناميكية\n\nالبرمجة الديناميكية تحل هذه المشكلة عن طريق تخزين نتائج الحسابات الفرعية لتجنب إعادة حسابها. هناك طريقتان رئيسيتان:\n\n1.  **الجدولة (Tabulation - Bottom-Up Approach)**: نبني الحل من الأسفل إلى الأعلى.\n2.  **الحل المحسّن للمساحة (Space Optimized Approach)**: وهو تحسين للطريقة الأولى لتقليل استهلاك الذاكرة.\n\n--- \n\n### الطريقة الأولى: الجدولة (Tabulation)\n\nفي هذه الطريقة، نقوم بإنشاء مصفوفة (جدول) لتخزين قيم فيبوناتشي من 0 حتى n. نبدأ بملء القيم الأساسية ثم نستخدمها لحساب القيم التالية.\n\n**الخطوات:**\n\n1.  إنشاء مصفوفة `dp` بحجم `n+1`.\n2.  تخزين الحالات الأساسية: `dp[0] = 0` و `dp[1] = 1`.\n3.  المرور في حلقة تكرارية من `i = 2` إلى `n`.\n4.  في كل دورة، يتم حساب القيمة الجديدة: `dp[i] = dp[i-1] + dp[i-2]`.\n5.  النتيجة النهائية هي القيمة الموجودة في `dp[n]`.\n\n**الكود (بايثون):**\n\n```python\ndef fibonacci_tabulation(n):\n    # التعامل مع الحالات الأساسية إذا كانت n صغيرة\n    if n <= 1:\n        return n\n    \n    # إنشاء مصفوفة لتخزين النتائج بحجم n+1\n    dp = [0] * (n + 1)\n    \n    # تحديد القيمة الأولية\n    dp[1] = 1\n    \n    # بناء الجدول من الأسفل إلى الأعلى\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n        \n    return dp[n]\n\n# مثال للاستخدام\nnum = 10\nresult = fibonacci_tabulation(num)\nprint(f\"العدد الفيبوناتشي رقم {num} هو: {result}\")\n# المخرجات: العدد الفيبوناتشي رقم 10 هو: 55\n```\n\n**تحليل التعقيد:**\n*   **التعقيد الزمني (Time Complexity):** `O(n)` لأننا نمر على الحلقة مرة واحدة من 2 إلى n.\n*   **التعقيد المكاني (Space Complexity):** `O(n)` لأننا نستخدم مصفوفة إضافية بحجم n.\n\n--- \n\n### الطريقة الثانية: الحل المحسّن للمساحة (Space Optimized)\n\nيمكننا ملاحظة أنه لحساب العدد الفيبوناتشي الحالي، نحتاج فقط إلى العددين السابقين له. لذا، لا داعي لتخزين المتتالية بأكملها في مصفوفة. يمكننا استخدام ثلاثة متغيرات فقط لتتبع آخر قيمتين والقيمة الحالية.\n\n**الخطوات:**\n1.  التعامل مع الحالات الأساسية `n=0` و `n=1`.\n2.  تعريف متغيرين لتخزين آخر قيمتين، `a = 0` و `b = 1`.\n3.  المرور في حلقة تكرارية من 2 إلى `n`.\n4.  في كل دورة، نحسب القيمة التالية `c = a + b`.\n5.  نقوم بتحديث المتغيرات: `a` تصبح قيمة `b` القديمة، و`b` تصبح قيمة `c` الجديدة.\n6.  بعد انتهاء الحلقة، تكون النتيجة هي قيمة `b`.\n\n**الكود (بايثون):**\n\n```python\ndef fibonacci_optimized(n):\n    # التعامل مع الحالات الأساسية\n    if n <= 1:\n        return n\n    \n    # a يمثل الرقم (i-2) و b يمثل الرقم (i-1)\n    a, b = 0, 1\n    \n    # المرور في حلقة من 2 إلى n\n    for _ in range(2, n + 1):\n        # حساب الرقم الجديد وتحديث المتغيرات\n        c = a + b\n        a = b\n        b = c\n        \n    return b\n\n# مثال للاستخدام\nnum = 10\nresult = fibonacci_optimized(num)\nprint(f\"العدد الفيبوناتشي رقم {num} هو: {result}\")\n# المخرجات: العدد الفيبوناتشي رقم 10 هو: 55\n```\n\n**تحليل التعقيد:**\n*   **التعقيد الزمني (Time Complexity):** `O(n)`، لا يزال خطيًا.\n*   **التعقيد المكاني (Space Complexity):** `O(1)`، وهو تحسن كبير حيث نستخدم عدداً ثابتاً من المتغيرات بغض النظر عن قيمة n.\n\n### الخلاصة\n\nتعتبر طريقة البرمجة الديناميكية المحسّنة للمساحة هي الطريقة الأكثر كفاءة لحساب أعداد فيبوناتشي، حيث توفر أداءً زمنيًا خطيًا مع استهلاك ذاكرة ثابت."}
{"question_id":75,"category":"vicuna_ar","sub-category":"coding","turns":["قم بتنفيذ خوارزمية البحث الثنائي للعثور على عنصر محدد في مصفوفة مرتبة."],"answer":"خوارزمية البحث الثنائي (Binary Search) هي خوارزمية بحث فعالة تُستخدم للعثور على قيمة معينة ضمن مصفوفة مرتبة.\n\n**المبدأ الأساسي:**\nتعتمد الخوارزمية على تقسيم نطاق البحث إلى النصف في كل خطوة، مما يقلل بشكل كبير من عدد المقارنات المطلوبة للعثور على العنصر.\n\n**شروط الاستخدام:**\nيجب أن تكون المصفوفة مرتبة (إما تصاعديًا أو تنازليًا) قبل تطبيق الخوارزمية.\n\n**خطوات تنفيذ الخوارزمية:**\n\n1.  **تحديد نطاق البحث:**\n    *   ابدأ بمؤشرين: مؤشر بداية (`low` أو `left`) يشير إلى أول عنصر في المصفوفة (فهرس 0).\n    *   مؤشر نهاية (`high` أو `right`) يشير إلى آخر عنصر في المصفوفة (فهرس `n-1` حيث `n` هو حجم المصفوفة).\n\n2.  **التكرار والبحث:**\n    *   استمر في حلقة تكرارية طالما أن مؤشر البداية (`low`) أصغر من أو يساوي مؤشر النهاية (`high`).\n\n3.  **إيجاد العنصر الأوسط:**\n    *   في كل تكرار، احسب الفهرس الأوسط (`mid`) للنطاق الحالي: `mid = low + (high - low) \/ 2`.\n\n4.  **مقارنة العنصر الأوسط بالهدف:**\n    *   **الحالة 1: تم العثور على العنصر.** إذا كانت قيمة العنصر في الفهرس الأوسط (`array[mid]`) تساوي القيمة المستهدفة، فإن البحث ينتهي بنجاح، ويتم إرجاع الفهرس `mid`.\n    *   **الحالة 2: الهدف أصغر.** إذا كانت القيمة المستهدفة أصغر من قيمة العنصر الأوسط، فهذا يعني أن الهدف (إذا كان موجودًا) يقع في النصف الأيسر من النطاق. لذلك، يتم تجاهل النصف الأيمن عن طريق تحديث مؤشر النهاية ليصبح `high = mid - 1`.\n    *   **الحالة 3: الهدف أكبر.** إذا كانت القيمة المستهدفة أكبر من قيمة العنصر الأوسط، فهذا يعني أن الهدف (إذا كان موجودًا) يقع في النصف الأيمن من النطاق. لذلك، يتم تجاهل النصف الأيسر عن طريق تحديث مؤشر البداية ليصبح `low = mid + 1`.\n\n5.  **انتهاء البحث (العنصر غير موجود):**\n    *   إذا انتهت الحلقة التكرارية (أي أصبح `low` أكبر من `high`)، فهذا يعني أن العنصر المستهدف غير موجود في المصفوفة. في هذه الحالة، يمكن إرجاع قيمة تدل على الفشل (مثل -1).\n\n**مثال عملي:**\n\nلنفترض أن لدينا المصفوفة المرتبة: `arr = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]`\nوالهدف هو البحث عن الرقم `23`.\n\n*   **الخطوة 1:** `low = 0`, `high = 9`\n    *   `mid = 0 + (9 - 0) \/ 2 = 4`\n    *   `arr[4]` هو `16`. بما أن `23 > 16`، فإننا نبحث في النصف الأيمن. نُحدّث `low = mid + 1 = 5`.\n\n*   **الخطوة 2:** `low = 5`, `high = 9`\n    *   `mid = 5 + (9 - 5) \/ 2 = 7`\n    *   `arr[7]` هو `56`. بما أن `23 < 56`، فإننا نبحث في النصف الأيسر. نُحدّث `high = mid - 1 = 6`.\n\n*   **الخطوة 3:** `low = 5`, `high = 6`\n    *   `mid = 5 + (6 - 5) \/ 2 = 5`\n    *   `arr[5]` هو `23`. بما أن `23 == 23`، تم العثور على العنصر عند الفهرس `5`."}
{"question_id":76,"category":"vicuna_ar","sub-category":"coding","turns":["قم بتنفيذ بنية بيانات قائمة انتظار في بايثون باستخدام كومتين."],"answer":"بالتأكيد، يمكنك تنفيذ بنية بيانات قائمة انتظار (Queue) التي تتبع مبدأ \"من يدخل أولاً يخرج أولاً\" (FIFO) باستخدام كومتين (Stacks) تتبعان مبدأ \"من يدخل أخيراً يخرج أولاً\" (LIFO). الفكرة هي استخدام كومة واحدة لعمليات الإضافة (enqueue) وكومة أخرى لعمليات الحذف (dequeue).\n\n### الفكرة الأساسية\n\n1.  **للإضافة (Enqueue):** نقوم دائمًا بإضافة العنصر الجديد إلى الكومة الأولى (`stack1`). هذه عملية سريعة بتعقيد زمني O(1).\n2.  **للحذف (Dequeue):**\n    *   نتحقق من الكومة الثانية (`stack2`). إذا كانت تحتوي على عناصر، فإن العنصر الموجود في قمتها هو أقدم عنصر تم إدخاله، لذا نقوم بسحبه (pop) وإرجاعه.\n    *   إذا كانت الكومة الثانية (`stack2`) فارغة، فهذا يعني أننا بحاجة إلى نقل العناصر من الكومة الأولى (`stack1`) إليها. نقوم بسحب كل عنصر من `stack1` ودفعه إلى `stack2`. هذه العملية تعكس ترتيب العناصر، مما يجعل العنصر الأول الذي تم إدخاله في `stack1` هو الأخير الذي يتم إدخاله في `stack2` (أي في قمة `stack2`).\n    *   بعد نقل العناصر، نقوم بسحب (pop) العنصر من قمة `stack2`.\n    *   إذا كانت كلتا الكومتين فارغتين، فإن قائمة الانتظار فارغة.\n\nهذه الطريقة فعالة لأن كل عنصر يتم نقله مرتين كحد أقصى (مرة إلى `stack1` ومرة إلى `stack2`)، مما يجعل التعقيد الزمني لعملية الحذف **O(1) في المتوسط (Amortized)**.\n\n### التنفيذ في بايثون\n\nإليك كود بايثون كامل يوضح كيفية تنفيذ ذلك:\n\n```python\nclass QueueWithTwoStacks:\n    def __init__(self):\n        \"\"\"\n        نقوم بتهيئة كومتين، واحدة للإدخال والأخرى للإخراج.\n        \"\"\"\n        self.stack_in = []  # الكومة التي تستقبل العناصر الجديدة (مثل عملية enqueue)\n        self.stack_out = [] # الكومة التي نأخذ منها العناصر (مثل عملية dequeue)\n\n    def enqueue(self, item):\n        \"\"\"\n        إضافة عنصر إلى نهاية قائمة الانتظار.\n        هذه العملية دائمًا O(1).\n        \"\"\"\n        self.stack_in.append(item)\n        print(f\"Enqueued: {item}\")\n\n    def dequeue(self):\n        \"\"\"\n        إزالة وإرجاع العنصر من بداية قائمة الانتظار.\n        \"\"\"\n        # إذا كانت كومة الإخراج فارغة، نقوم بنقل العناصر من كومة الإدخال.\n        if not self.stack_out:\n            # إذا كانت كلتا الكومتين فارغتين، فقائمة الانتظار فارغة.\n            if not self.stack_in:\n                return \"Error: Queue is empty\"\n            \n            print(\"Transferring elements from stack_in to stack_out...\")\n            # نقل جميع العناصر من stack_in إلى stack_out لعكس الترتيب.\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        \n        # الآن العنصر في قمة stack_out هو العنصر الأول الذي تم إدخاله.\n        return self.stack_out.pop()\n\n    def is_empty(self):\n        \"\"\"\n        التحقق مما إذا كانت قائمة الانتظار فارغة.\n        \"\"\"\n        return not self.stack_in and not self.stack_out\n\n    def size(self):\n        \"\"\"\n        إرجاع عدد العناصر في قائمة الانتظار.\n        \"\"\"\n        return len(self.stack_in) + len(self.stack_out)\n\n# --- مثال على الاستخدام ---\nif __name__ == \"__main__\":\n    queue = QueueWithTwoStacks()\n\n    # إضافة عناصر إلى قائمة الانتظار\n    queue.enqueue(10)\n    queue.enqueue(20)\n    queue.enqueue(30)\n\n    # إزالة عنصر (يجب أن يكون 10 لأنه الأول)\n    # في هذه المرحلة، stack_out فارغة، لذا سيتم نقل العناصر\n    print(f\"Dequeued: {queue.dequeue()}\") # سيطبع 10\n\n    # إزالة عنصر آخر (يجب أن يكون 20)\n    print(f\"Dequeued: {queue.dequeue()}\") # سيطبع 20\n\n    # إضافة عنصر جديد\n    queue.enqueue(40)\n\n    # إزالة العناصر المتبقية للتأكد من الترتيب الصحيح\n    print(f\"Dequeued: {queue.dequeue()}\") # سيطبع 30\n    print(f\"Dequeued: {queue.dequeue()}\") # سيطبع 40\n    \n    # محاولة الحذف من قائمة انتظار فارغة\n    print(f\"Dequeued: {queue.dequeue()}\") # سيطبع \"Error: Queue is empty\"\n\n    # التحقق مما إذا كانت فارغة\n    print(f\"Is queue empty? {queue.is_empty()}\") # سيطبع True\n```\n\n### شرح المثال\n\n1.  نضيف `10`, `20`, `30`. الآن `stack_in` هي `[10, 20, 30]` و `stack_out` فارغة.\n2.  عند استدعاء `dequeue()` لأول مرة، يلاحظ أن `stack_out` فارغة. يتم نقل العناصر من `stack_in` إلى `stack_out`.\n    *   بعد النقل، تصبح `stack_in` فارغة وتصبح `stack_out` هي `[30, 20, 10]`.\n    *   يتم سحب (pop) العنصر `10` من `stack_out` وإرجاعه.\n3.  عند استدعاء `dequeue()` مرة أخرى، `stack_out` تحتوي على `[30, 20]`. يتم سحب `20` مباشرة.\n4.  نضيف `40`. تصبح `stack_in` هي `[40]`.\n5.  عند استدعاء `dequeue()`، `stack_out` لا تزال تحتوي على `[30]`. يتم سحب `30`.\n6.  عند استدعاء `dequeue()` مرة أخرى، `stack_out` فارغة الآن. يتم نقل العنصر `40` من `stack_in` إلى `stack_out`. ثم يتم سحبه."}
{"question_id":77,"category":"vicuna_ar","sub-category":"coding","turns":["قم بتنفيذ برنامج للعثور على العناصر المشتركة في مصفوفتين دون استخدام أي هياكل بيانات إضافية."],"answer":"بالتأكيد، إليك شرح كامل لطريقتين لتنفيذ برنامج يعثر على العناصر المشتركة بين مصفوفتين دون استخدام هياكل بيانات إضافية مثل (Hash set أو Dictionary).\n\n### الطريقة الأولى: استخدام الحلقات المتداخلة (Brute-Force)\n\nهذه هي الطريقة الأكثر مباشرة وبساطة. تعتمد على المرور على كل عنصر في المصفوفة الأولى ومقارنته مع كل عنصر في المصفوفة الثانية.\n\n**الخطوات:**\n1.  أنشئ قائمة فارغة (لتكون النتيجة النهائية) لتخزين العناصر المشتركة.\n2.  ابدأ حلقة تكرارية خارجية للمرور على كل عنصر (`elem1`) في المصفوفة الأولى (`array1`).\n3.  داخل هذه الحلقة، ابدأ حلقة تكرارية داخلية للمرور على كل عنصر (`elem2`) في المصفوفة الثانية (`array2`).\n4.  في كل تكرار للحلقة الداخلية، قارن `elem1` مع `elem2`.\n5.  إذا كان العنصران متساويين، تحقق أولاً مما إذا كان هذا العنصر موجودًا بالفعل في قائمة النتائج (لتجنب تكرار نفس العنصر). إذا لم يكن موجودًا، أضفه إلى قائمة النتائج.\n6.  بعد انتهاء جميع الحلقات، ستكون قائمة النتائج تحتوي على جميع العناصر المشتركة الفريدة.\n\n**مثال بالكود (بايثون):**\n```python\ndef find_common_bruteforce(arr1, arr2):\n    common_elements = []\n    for x in arr1:\n        for y in arr2:\n            if x == y and x not in common_elements:\n                common_elements.append(x)\n    return common_elements\n\n# مثال للاستخدام\narray1 = [1, 2, 3, 4, 5]\narray2 = [4, 5, 6, 7, 8]\nprint(find_common_bruteforce(array1, array2))  # سيطبع: [4, 5]\n```\n\n*   **التعقيد الزمني (Time Complexity):** `O(n * m)` حيث `n` هو طول المصفوفة الأولى و `m` هو طول المصفوفة الثانية. هذه الطريقة تصبح بطيئة جدًا مع المصفوفات الكبيرة.\n\n---\n\n### الطريقة الثانية: الترتيب واستخدام المؤشرات (Sort and Two-Pointers)\n\nهذه الطريقة أكثر كفاءة بكثير، خاصة للمصفوفات الكبيرة. تتطلب ترتيب المصفوفتين أولاً، وهذا مسموح به لأنه يغير المصفوفات نفسها ولا يستخدم هيكل بيانات إضافي للتخزين المؤقت.\n\n**الخطوات:**\n1.  قم بترتيب كل من المصفوفتين (`array1` و `array2`) تصاعديًا.\n2.  عرّف مؤشرين (pointers)، `i` للمصفوفة الأولى و `j` للمصفوفة الثانية. ابدأ كلاهما من الموقع 0.\n3.  أنشئ قائمة فارغة لتخزين النتائج.\n4.  استخدم حلقة `while` تستمر طالما أن المؤشر `i` لم يتجاوز نهاية `array1` والمؤشر `j` لم يتجاوز نهاية `array2`.\n5.  داخل الحلقة، قم بالمقارنة:\n    *   إذا كان `array1[i]` **أصغر من** `array2[j]`، فهذا يعني أننا بحاجة للبحث عن قيمة أكبر في `array1`، لذا قم بزيادة `i` بمقدار 1.\n    *   إذا كان `array1[i]` **أكبر من** `array2[j]`، فهذا يعني أننا بحاجة للبحث عن قيمة أكبر في `array2`، لذا قم بزيادة `j` بمقدار 1.\n    *   إذا كان `array1[i]` **يساوي** `array2[j]`، فهذا يعني أننا وجدنا عنصرًا مشتركًا. أضفه إلى قائمة النتائج (مع التأكد من عدم إضافته مرة أخرى إذا كانت هناك تكرارات)، ثم قم بزيادة كل من `i` و `j` بمقدار 1 للانتقال إلى العناصر التالية.\n6.  ستحتوي قائمة النتائج على العناصر المشتركة عند انتهاء الحلقة.\n\n**مثال بالكود (بايثون):**\n```python\ndef find_common_sorted(arr1, arr2):\n    # الخطوة 1: ترتيب المصفوفتين\n    arr1.sort()\n    arr2.sort()\n\n    i, j = 0, 0\n    common_elements = []\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr1[i] > arr2[j]:\n            j += 1\n        else:  # العناصر متساوية\n            # تجنب إضافة نفس العنصر المكرر\n            if not common_elements or common_elements[-1] != arr1[i]:\n                common_elements.append(arr1[i])\n            i += 1\n            j += 1\n            \n    return common_elements\n\n# مثال للاستخدام\narray1 = [1, 5, 4, 2, 3]\narray2 = [8, 4, 6, 7, 5]\nprint(find_common_sorted(array1, array2)) # سيطبع: [4, 5]\n```\n\n*   **التعقيد الزمني (Time Complexity):** `O(n log n + m log m)` بسبب عملية الترتيب. بعد الترتيب، تكون عملية البحث خطية `O(n + m)`. هذه الطريقة أسرع بكثير من الطريقة الأولى للمجموعات الكبيرة من البيانات.\n\n### الخلاصة\n*   **الطريقة الأولى (الحلقات المتداخلة):** سهلة الفهم والتنفيذ ولكنها غير فعالة للمصفوفات الكبيرة.\n*   **الطريقة الثانية (الترتيب والمؤشرات):** أكثر تعقيدًا قليلاً ولكنها أسرع وأكثر كفاءة بكثير، وهي الحل المفضل في معظم الحالات العملية."}
{"question_id":78,"category":"vicuna_ar","sub-category":"math","turns":["بالنظر إلى أن f(x) = 5x^3 - 2x + 3، احسب قيمة f(2)."],"answer":"لإيجاد قيمة f(2)، نعوض عن كل x في الدالة بالرقم 2:\n f(x) = 5x^3 - 2x + 3\n f(2) = 5(2)^3 - 2(2) + 3\n\nأولاً، نحسب قيمة الأس:\n 2^3 = 8\n\nالآن، نعوض بهذه القيمة في المعادلة:\n f(2) = 5(8) - 2(2) + 3\n\nبعد ذلك، نقوم بعمليات الضرب:\n f(2) = 40 - 4 + 3\n\nأخيراً، نقوم بعمليات الطرح والجمع بالترتيب:\n f(2) = 36 + 3\n f(2) = 39\n\nإذًا، قيمة f(2) هي 39."}
{"question_id":79,"category":"vicuna_ar","sub-category":"math","turns":["ابحث عن قيمة x في المعادلة 3x + 10 = 5(x - 2)"],"answer":"لحل المعادلة 3x + 10 = 5(x - 2) وإيجاد قيمة x، اتبع الخطوات التالية:\n\n1.  **فك القوس:** ابدأ بتوزيع الرقم 5 على الحدود الموجودة داخل القوس في الطرف الأيمن من المعادلة.\n    5 * x = 5x\n    5 * -2 = -10\n    بذلك تصبح المعادلة:\n    3x + 10 = 5x - 10\n\n2.  **تجميع المتغيرات في طرف واحد:** اجمع كل الحدود التي تحتوي على المتغير x في طرف واحد. يمكننا فعل ذلك بطرح 3x من كلا الطرفين.\n    3x - 3x + 10 = 5x - 3x - 10\n    10 = 2x - 10\n\n3.  **تجميع الأعداد الثابتة في الطرف الآخر:** الآن، اجمع الأعداد الثابتة (الأرقام بدون متغير) في الطرف المقابل. يمكننا فعل ذلك بإضافة 10 إلى كلا الطرفين.\n    10 + 10 = 2x - 10 + 10\n    20 = 2x\n\n4.  **إيجاد قيمة x:** الخطوة الأخيرة هي عزل x. قم بقسمة كلا الطرفين على معامل x وهو 2.\n    20 \/ 2 = 2x \/ 2\n    10 = x\n\nإذًا، قيمة x في المعادلة هي 10."}
{"question_id":80,"category":"vicuna_ar","sub-category":"math","turns":["ما هو طول القطعة الخطية إذا كانت نقاط النهاية لها (2، -2) و (10، 4)؟"],"answer":"لإيجاد طول القطعة الخطية، نستخدم صيغة المسافة بين نقطتين:\n\nالصيغة: د = √[(س₂ - س₁)² + (ص₂ - ص₁)²]\n\nحيث أن نقاط النهاية هي (س₁, ص₁) = (2, -2) و (س₂, ص₂) = (10, 4).\n\n1. **التعويض بالقيم في الصيغة:**\n   د = √[(10 - 2)² + (4 - (-2))²]\n\n2. **تبسيط الأقواس:**\n   د = √[(8)² + (6)²]\n\n3. **حساب المربعات:**\n   د = √[64 + 36]\n\n4. **جمع القيم:**\n   د = √[100]\n\n5. **حساب الجذر التربيعي:**\n   د = 10\n\nإذًا، طول القطعة الخطية هو 10 وحدات."}
